<!DOCTYPE html>
<html lang="en">

<head>
    <title>Scribble.rs - Game</title>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/resources/base.css"/>
    <link rel="stylesheet" type="text/css" href="/resources/lobby.css"/>
    <link rel="icon" type="image/png" href="/resources/favicon.png"/>
</head>

<body>
<div class="content-wrapper">
    <div id="lobby">
        <noscript><span class="noscript">Hey, seems like you've disabled JavaScript.
            I get it ... but you are trying to play an interactive drawing game
            here, so you have to turn on JavaScript.</span></noscript>
        <span id="rounds"></span>

        <div style="position: relative">
            <div style="position: absolute">
                <!-- this button is basically behaving like a checkbox, but in order to
                have a uniform look with the other buttons in the header, we are not using
                a checkbox anymore. -->
                <button onclick="toggleSound()" class="dialog-button header-button"
                        alt="Toggle soundeffects" title="Toggle soundeffects">
                    <img id="sound-toggle-label" class="header-button-image"/>
                </button>

                <button onclick="showKickDialog()" class="dialog-button header-button"
                        alt="Votekick a player" title="Votekick a player">
                    <img src="/resources/kick.png" class="header-button-image"/>
                </button>

                <button onclick="showNameChangeDialog()" class="dialog-button header-button"
                        alt="Change your name" title="Change your name">
                    <img src="/resources/user.svg" class="header-button-image"/>
                </button>
            </div>
            <div id="word-container" style="position:absolute;left: 50%; transform: translate(-50%, 0);"></div>
        </div>

        <span id="time-left">Time Left: ∞</span>

        <div id="player-container"></div>

        <div id="drawing-board-wrapper">
            <div id="drawing-board-inner-wrapper">
                <canvas id="drawing-board"></canvas>

                <!-- The so called "center dialogs" are divs that float above the canvas.
                They are centered are always a fraction of the canvas size but never bigger.
                The "center-dialog-container" is basically like a "window" if you will and the
                "center-dialog" is the window content. Depending on which dialog
                we want to show, we show a different content. Technically there could be more
                than one dialog visible at a time, but they'll be layered. -->
                <div id="center-dialogs">
                    <div id="center-dialog-container">
                        <div id="word-dialog" class="center-dialog">
                            <span class="dialog-title">Choose a word</span>
                            <div class="center-dialog-content">
                                <div class="word-button-container">
                                    <button id="word-button-zero" class="dialog-button" onclick="chooseWord(0)">Placeholder
                                    </button>
                                    <button id="word-button-one" class="dialog-button" onclick="chooseWord(1)">Placeholder
                                    </button>
                                    <button id="word-button-two" class="dialog-button" onclick="chooseWord(2)">Placeholder
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="center-dialog-container">
                        <div id="start-dialog" class="center-dialog">
                            <span class="dialog-title">Start the game</span>
                            <div class="center-dialog-content">
                                <button class="dialog-button" onclick="startGame()">Start</button>
                            </div>
                        </div>
                    </div>

                    <div id="center-dialog-container">
                        <div id="unstarted-dialog" class="center-dialog">
                            <span class="dialog-title">Game hasn't started</span>
                            <div class="center-dialog-content">
                                Please wait for your lobby host to start the game.
                            </div>
                        </div>
                    </div>

                    <div id="center-dialog-container">
                        <div id="game-over-dialog" class="center-dialog">
                            <span id="game-over-dialog-title" class="dialog-title">Game over!</span>
                            <div id="game-over-scoreboard"></div>
                            <button id="restart-button" class="dialog-button" onclick="startGame()">Restart</button>
                        </div>
                    </div>

                    <div id="center-dialog-container">
                        <div id="kick-dialog" class="center-dialog">
                            <span class="dialog-title">Vote to kick a player</span>
                            <div id="kick-dialog-players"></div>
                            <button onclick="hideKickDialog()" class="dialog-button dialog-close-button">Close</button>
                        </div>
                    </div>

                    <div id="center-dialog-container">
                        <div id="reconnect-dialog" class="center-dialog">
                            <span id="game-over-dialog-title" class="dialog-title">Connection lost!</span>
                            <p>Attempting to reconnect ...</p>
                            <p>Make sure your internet connection works.<br/>If the problem persists, contact the webmaster.</p>
                        </div>
                    </div>
                </div>
                <div id="toolbox">
                    <input class="toolbox-group" type="color" id="color-picker" onchange="setColor()" value="#000000"
                            alt="Current color (Click to change)" title="Current color (Click to change)">
                    <div class="color-button-container toolbox-group">
                        <!-- These buttons use !important for their color in order
                        to prevent hover and active colors to appear. -->
                        <div class="color-button-row">
                            <button class="color-button" style="background-color: #ffffff !Important"
                                    onmousedown="setColor('#ffffff')" onclick="setColor('#ffffff')"></button>
                            <button class="color-button" style="background-color: #c1c1c1 !Important"
                                    onmousedown="setColor('#c1c1c1')" onclick="setColor('#c1c1c1')"></button>
                            <button class="color-button" style="background-color: #ef130b !Important"
                                    onmousedown="setColor('#ef130b')" onclick="setColor('#ef130b')"></button>
                            <button class="color-button" style="background-color: #ff7100 !Important"
                                    onmousedown="setColor('#ff7100')" onclick="setColor('#ff7100')"></button>
                            <button class="color-button" style="background-color: #ffe400 !Important"
                                    onmousedown="setColor('#ffe400')" onclick="setColor('#ffe400')"></button>
                            <button class="color-button" style="background-color: #00cc00 !Important"
                                    onmousedown="setColor('#00cc00')" onclick="setColor('#00cc00')"></button>
                            <button class="color-button" style="background-color: #00b2ff !Important"
                                    onmousedown="setColor('#00b2ff')" onclick="setColor('#00b2ff')"></button>
                            <button class="color-button" style="background-color: #231fd3 !Important"
                                    onmousedown="setColor('#231fd3')" onclick="setColor('#231fd3')"></button>
                            <button class="color-button" style="background-color: #a300ba !Important"
                                    onmousedown="setColor('#a300ba')" onclick="setColor('#a300ba')"></button>
                            <button class="color-button" style="background-color: #d37caa !Important"
                                    onmousedown="setColor('#d37caa')" onclick="setColor('#d37caa')"></button>
                            <button class="color-button" style="background-color: #a0522d !Important"
                                    onmousedown="setColor('#a0522d')" onclick="setColor('#a0522d')"></button>
                        </div>
                        <div class="color-button-row">
                            <button class="color-button" style="background-color: #000000 !Important"
                                    onmousedown="setColor('#000000')" onclick="setColor('#000000')"></button>
                            <button class="color-button" style="background-color: #4c4c4c !Important"
                                    onmousedown="setColor('#4c4c4c')" onclick="setColor('#4c4c4c')"></button>
                            <button class="color-button" style="background-color: #740b07 !Important"
                                    onmousedown="setColor('#740b07')" onclick="setColor('#740b07')"></button>
                            <button class="color-button" style="background-color: #c23800 !Important"
                                    onmousedown="setColor('#c23800')" onclick="setColor('#c23800')"></button>
                            <button class="color-button" style="background-color: #e8a200 !Important"
                                    onmousedown="setColor('#e8a200')" onclick="setColor('#e8a200')"></button>
                            <button class="color-button" style="background-color: #005510 !Important"
                                    onmousedown="setColor('#005510')" onclick="setColor('#005510')"></button>
                            <button class="color-button" style="background-color: #00569e !Important"
                                    onmousedown="setColor('#00569e')" onclick="setColor('#00569e')"></button>
                            <button class="color-button" style="background-color: #0e0865 !Important"
                                    onmousedown="setColor('#0e0865')" onclick="setColor('#0e0865')"></button>
                            <button class="color-button" style="background-color: #550069 !Important"
                                    onmousedown="setColor('#550069')" onclick="setColor('#550069')"></button>
                            <button class="color-button" style="background-color: #a75574 !Important"
                                    onmousedown="setColor('#a75574')" onclick="setColor('#a75574')"></button>
                            <button class="color-button" style="background-color: #63300d !Important"
                                    onmousedown="setColor('#63300d')" onclick="setColor('#63300d')"></button>
                        </div>
                    </div>
                    <!--The following buttons als override onmousedown and onmouseup to make
                        selection more foolproof. This was done, because many people seem to
                        only make half a click (either up or down) in the right location.-->
                    <div class="pencil-sizes-container toolbox-group">
                        <label for="tool-type-pencil">
                            <input id="tool-type-pencil" class="custom-check-or-radio line-width-button"
                                onchange="chooseTool(pen)" type="radio" name="tool-type" checked>
                            <div
                                onmousedown="document.getElementById('tool-type-pencil').click()"
                                onmouseup="document.getElementById('tool-type-pencil').click()"
                                class="line-width-button-content">
                                <span  id="tool-type-pencil-button" style="font-size: 2rem;">✏️</span>
                            </div>
                        </label>
                        <label for="tool-type-fill">
                            <input id="tool-type-fill" class="custom-check-or-radio line-width-button"
                                onchange="chooseTool(fillBucket)" type="radio" name="tool-type">
                            <div 
                                onmousedown="document.getElementById('tool-type-fill').click()"
                                onmouseup="document.getElementById('tool-type-fill').click()"
                                class="line-width-button-content">
                                <img alt="Fill" title="Fill tool" src="/resources/fill.svg" width="40px"
                                    height="40px"/>
                            </div>
                        </label>
                        <label for="tool-type-rubber">
                            <input id="tool-type-rubber" class="custom-check-or-radio line-width-button"
                                    onchange="chooseTool(rubber)" type="radio" name="tool-type">
                            <div
                                onmousedown="document.getElementById('tool-type-rubber').click()"
                                onmouseup="document.getElementById('tool-type-rubber').click()"
                                class="line-width-button-content">
                                <img alt="Rubber" title="Rubber tool" src="/resources/rubber.svg" width="40px"
                                    height="40px"/>
                            </div>
                        </label>
                    </div>
                    <div class="pencil-sizes-container toolbox-group">
                        <label for="size8">
                            <input id="size8" class="custom-check-or-radio line-width-button" onchange="setLineWidth(8)"
                                    type="radio" name="line-width" checked>
                            <div
                                onmousedown="document.getElementById('size8').click()"
                                onmouseup="document.getElementById('size8').click()"
                                class="line-width-button-content">
                                <div id="size-8-button" class="dot"></div>
                            </div>
                        </label>
                        <label for="size15">
                            <input id="size15" class="custom-check-or-radio line-width-button"
                                    onchange="setLineWidth(15)"
                                    type="radio" name="line-width">
                            <div
                                onmousedown="document.getElementById('size15').click()"
                                onmouseup="document.getElementById('size15').click()"
                                class="line-width-button-content">
                                <div id="size-15-button" class="dot"></div>
                            </div>
                        </label>
                        <label for="size30">
                            <input id="size30" class="custom-check-or-radio line-width-button"
                                    onchange="setLineWidth(30)"
                                    type="radio" name="line-width">
                                <div
                                    onmousedown="document.getElementById('size30').click()"
                                    onmouseup="document.getElementById('size30').click()"
                                    class="line-width-button-content">
                                    <div id="size-30-button" class="dot"></div>
                            </div>
                        </label>
                        <label for="size40">
                            <input id="size40" class="custom-check-or-radio line-width-button"
                                    onchange="setLineWidth(40)"
                                    type="radio" name="line-width">
                                <div
                                    onmousedown="document.getElementById('size40').click()"
                                    onmouseup="document.getElementById('size40').click()"
                                    class="line-width-button-content">
                                <div id="size-40-button" class="dot"></div>
                            </div>
                        </label>
                    </div>
                    <!--We won't make this button easier to click, as there's no going back. -->
                    <button class="canvas-button toolbox-group" style="font-size: 2rem;"
                            onclick="clearCanvasAndSendEvent()"
                            alt="Clear the canvas" title="Clear the canvas">🗑
                    </button>
                </div>
            </div>
        </div>

        <div id="chat">
            <div id="message-container"></div>
            <form class="message-input-form" onsubmit="return sendMessage()">
                <input id="message-input" type="text" autocomplete="off" placeholder="Type your message"/>
            </form>
        </div>
    </div>

    {{template "footer"}}
</div>

<script type="text/javascript" src="/resources/floodfill.js"></script>
<script type="text/javascript">
    const reconnectDialog = document.getElementById("reconnect-dialog");
    let socketIsConnecting = false;
    let socket;
    function connectToWebsocket() {
        if (socketIsConnecting === true) {
            return;
        }
        socketIsConnecting = true;

        if (location.protocol === 'https:') {
            console.log("Attempting secure socket connection on port " + location.port + "...");
            socket = new WebSocket("wss://" + location.hostname + ":" + location.port + "/v1/ws?lobby_id={{.LobbyID}}");
        } else {
            console.log("Attempting socket connection on port " + location.port + "...");
            socket = new WebSocket("ws://" + location.hostname + ":" + location.port + "/v1/ws?lobby_id={{.LobbyID}}");
        }

        socket.onopen = () => {
            reconnectDialog.style.visibility = "hidden";
            socket.onclose = event => {
                console.log("Socket Closed Connection: ", event);
                console.log("Attempting to reestablish socket connection.");
                reconnectDialog.style.visibility = "visible";
                connectToWebsocket();
            };
            socket.onerror = error => console.log("Socket Error: ", error);

            socketIsConnecting = false;
            console.log("Successfully Connected");
        };
    }

    connectToWebsocket();

    //In order to avoid automatically canceling the socket connection, we keep
    //sending dummy events every 5 seconds. This was a problem on Heroku. If
    //a player took a very long time to choose a word, the connection of all
    //players could be killed and even cause the lobby being closed. Since
    //that's very frustrating, we want to avoid that.
    window.setInterval(() => {
        socket.send(JSON.stringify({type: "keep-alive"}));
    }, 5000);

    //Makes sure that the server notices that the player disconnects.
    //Otherwise a refresh (on chromium based browsers) can lead to the server
    //thinking that there's already an open tab with this lobby.
    window.onbeforeunload = () => {
        //Avoid unintentionally reestablishing connection.
        socket.onclose = null;
        socket.close();
    };

    const messageInput = document.getElementById("message-input");
    const playerContainer = document.getElementById("player-container");
    const wordContainer = document.getElementById("word-container");
    const messageContainer = document.getElementById("message-container");
    const roundsSpan = document.getElementById("rounds");
    const timeLeft = document.getElementById("time-left");
    const drawingBoard = document.getElementById("drawing-board");
    const chat = document.getElementById("chat");

    const toolBox = document.getElementById("toolbox");
    const colorPicker = document.getElementById("color-picker");

    const centerDialog = document.getElementById("center-dialog");
    const unstartedDialog = document.getElementById("unstarted-dialog");
    const startDialog = document.getElementById("start-dialog");
    const gameOverDialog = document.getElementById("game-over-dialog");
    const gameOverDialogTitle = document.getElementById("game-over-dialog-title");
    const gameOverScoreboard = document.getElementById("game-over-scoreboard");
    const restartButton = document.getElementById("restart-button");
    const wordDialog = document.getElementById("word-dialog");
    const wordButtonZero = document.getElementById("word-button-zero");
    const wordButtonOne = document.getElementById("word-button-one");
    const wordButtonTwo = document.getElementById("word-button-two");

    const kickDialog = document.getElementById("kick-dialog");
    const kickDialogPlayers = document.getElementById("kick-dialog-players");

    const soundToggleLabel = document.getElementById("sound-toggle-label");
    let sound = localStorage.getItem("sound") !== "false";
    updateSoundIcon();

    function showKickDialog() {
        if (votekickEnabled !== true) {
            alert("Votekicking isn't enabled in this lobby.");
            return;
        }

        if (cachedPlayers && cachedPlayers) {
            kickDialogPlayers.innerHTML = "";

            cachedPlayers.forEach(player => {
                //Don't wanna allow kicking ourselves.
                if (player.id !== ownID) {
                    kickDialogPlayers.innerHTML += '<button class="kick-player-button" onclick="onVotekickPlayer(\'' + player.id + '\')">' + player.name + '</button>';
                }
            });

            kickDialog.style.visibility = "visible";
        }
    }

    function hideKickDialog() {
        kickDialog.style.visibility = "hidden";
    }

    function showNameChangeDialog() {
        let choice = prompt("Please choose your new name. Clearing the name will assign you a new random name.", ownName);
        //Hitting cancel results in null.
        //Since we pre fill the dialog with the current name, empty means that
        //it has been cleared on purpose.
        if (choice == null) {
            return;
        }

        // Username should be cleared.
        if (choice === "") {
            document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
        } else {
            //We already persist our new username here. If the backend doesn't like it, it will reset it either way.
            //Therefore it shouldn't matter.
            document.cookie = "username=" + choice + ";expires=Tue, 19 Jan 2038 00:00:00 UTC;path=/;samesite=strict";
        }

        socket.send(JSON.stringify({
            type: "name-change",
            data: choice,
        }));
    }

    function toggleSound() {
        sound = !sound;
        localStorage.setItem("sound", sound.toString());
        updateSoundIcon();
    }

    function updateSoundIcon() {
        if (sound) {
            soundToggleLabel.src = "/resources/sound.svg";
        } else {
            soundToggleLabel.src = "/resources/no-sound.svg";
        }
    }

    //The drawing board has a base size. This base size results in a certain ratio
    //that the actual canvas has to be resized accordingly too. This is needed
    //since not every client has the same screensize.
    let baseWidth = {{.DrawingBoardBaseWidth}};
    let baseHeight = {{.DrawingBoardBaseHeight}};
    let boardRatio = baseWidth / baseHeight;
    
    // Moving this here to extract the context after resizing
    const context = drawingBoard.getContext("2d");

    function handleCanvasResize() {
        //Resize canvas HTML element properly.
        drawingBoard.width = drawingBoard.clientWidth;
        drawingBoard.height = drawingBoard.clientHeight;
        setLineWidth(localLineWidthUnscaled);
        chat.style.maxHeight = drawingBoard.height + "px";
        toolBox.style.top = drawingBoard.height + "px";
    }

    function scaleUpFactor() {
        return baseWidth / drawingBoard.clientWidth;
    }

    function scaleDownFactor() {
        return drawingBoard.clientWidth / baseWidth;
    }

    const pen = 0;
    const rubber = 1;
    const fillBucket = 2;

    let allowDrawing = false;
    let localColor = "#000000";
    let localLineWidth;
    let localLineWidthUnscaled;
    let localTool = pen;
    setLineWidth(5);

    //Those are not scaled for now, as the whole toolbar would then have to incorrectly size up and down.
    document.getElementById("size-8-button").style.width = "8px";
    document.getElementById("size-8-button").style.height = "8px";
    document.getElementById("size-15-button").style.width = "15px";
    document.getElementById("size-15-button").style.height = "15px";
    document.getElementById("size-30-button").style.width = "30px";
    document.getElementById("size-30-button").style.height = "30px";
    document.getElementById("size-40-button").style.width = "40px";
    document.getElementById("size-40-button").style.height = "40px";

    function startGame() {
        socket.send(JSON.stringify({
            type: "start",
        }))
    }

    function setColor(value) {
        if (value === undefined) {
            localColor = colorPicker.value;
        } else {
            localColor = value;
            colorPicker.value = value;
        }
        updateCursor();
    }

    function setLineWidth(value) {
        localLineWidthUnscaled = value;
        localLineWidth = value * scaleDownFactor();
        updateCursor();
    }

    function chooseTool(value) {
        if (value === pen || value === rubber || value === fillBucket) {
            localTool = value;
        } else {
            //If this ends up with an invalid value, we use the pencil.
            localTool = pen;
        }
    }

    function hexToRgb(hex) {
        return hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => '#' + r + r + g + g + b + b)
            .substring(1).match(/.{2}/g)
            .map(x => parseInt(x, 16));
    }

    function updateCursor() {
        let cursorColor;
        let borderColor = "#FFFFFF";
        if (localColor.startsWith("#")) {
            cursorColor = hexToRgb(localColor);

            const hsp = Math.sqrt(
                0.299 * (cursorColor[0] * cursorColor[0]) +
                0.587 * (cursorColor[1] * cursorColor[1]) +
                0.114 * (cursorColor[2] * cursorColor[2])
            );

            if (hsp > 127.5) {
                borderColor = "rgb(0,0,0)";
            } else {
                borderColor = "rgb(255,255,255)";
            }

            cursorColor = "rgb(" + cursorColor[0] + "," + cursorColor[1] + "," + cursorColor[2] + ")";
        } else {
            cursorColor = localColor;
        }

        let circleSize = localLineWidth * scaleUpFactor();
        drawingBoard.style.cursor = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"" + (circleSize + 2) + "\" height=\"" + (circleSize + 2) + "\"><circle cx=\"" + (circleSize / 2) + "\" cy=\"" + (circleSize / 2) + "\" r=\"" + (circleSize / 2) + "\" style=\"fill: " + cursorColor + "; stroke: " + borderColor + ";\"/></svg>') " + (circleSize / 2) + " " + (circleSize / 2) + ", auto";
    }

    function clearCanvasAndSendEvent() {
        //Avoid unnecessary traffic back to us.
        clear(context);
        socket.send(JSON.stringify({
            type: "clear-drawing-board"
        }));
    }

    const sendMessage = () => {
        socket.send(JSON.stringify({
            type: "message",
            data: messageInput.value
        }));
        messageInput.value = "";

        // Necessary in order to keep the page from submitting.
        return false;
    };

    function chooseWord(index) {
        socket.send(JSON.stringify({
            type: "choose-word",
            data: index
        }));
        allowDrawing = true;
        wordDialog.style.visibility = "hidden";
    }

    function onVotekickPlayer(playerId) {
        socket.send(JSON.stringify({
            type: "kick-vote",
            data: playerId
        }));
        hideKickDialog();
    }

    //This automatically scrolls down the chat on arrivals of new messages
    new MutationObserver(() => messageContainer.scrollTop = messageContainer.scrollHeight)
        .observe(messageContainer, {
            attributes: false,
            childList: true,
            subtree: false
        });

    let ownID, ownerID, ownName;
    let maxRounds = 0;
    let roundEndTime = 0;
    let votekickEnabled
    socket.onmessage = event => {
        let parsed = JSON.parse(event.data);
        if (parsed.type === "ready") {
            let ready = parsed.data;
            handleReadyEvent(ready);
            if (ready.gameState === "unstarted") {
                if(ownerID === ownID) {
                    startDialog.style.visibility = "visible";
                } else {
                    unstartedDialog.style.visibility = "visible";
                }
            } else if (ready.gameState === "gameOver") {
                gameOverDialog.style.visibility = "visible";
                if(ownerID === ownID) {
                    restartButton.style.display = "block";
                }

                gameOverScoreboard.innerHTML = "";

                //Copying array so we can sort.
                let players = cachedPlayers.slice();
                players.sort((a,b) => {
                    return a.rank - b.rank;
                });

                for (let i = 0; i < players.length; i++) {
                    let player = players[i];
                    gameOverScoreboard.innerHTML += '<div class="gameover-scoreboard-entry">'
                            + '<div class="gameover-scoreboard-rank">'
                                +player.rank
                            + '</div>'
                            + '<div class="gameover-scoreboard-name">'
                                + player.name 
                            +'</div>'
                        + '</div>';
                    if (player.id === ownID) {
                        if (player.rank == 1) {
                            gameOverDialogTitle.innerHTML = "Picasso, is it you?";
                        } else {
                            gameOverDialogTitle.innerHTML = "Next time you'll win!";
                        }
                    }
                }
            }
        } else if (parsed.type === "update-players") {
            applyPlayers(parsed.data);
        } else if (parsed.type === "correct-guess") {
            playWav('/resources/plop.wav');

            if (parsed.data === ownID) {
                applyMessage("correct-guess-message", "System", "You have correctly guessed the word.")
            } else {
                for (let i = 0; i < cachedPlayers.length; i++) {
                    let player = cachedPlayers[i];
                    if (player.id === parsed.data) {
                        applyMessage("correct-guess-message", "System", player.name + " correctly guessed the word.")
                        break;
                    }
                }
            }
        } else if (parsed.type === "close-guess") {
            applyMessage("close-guess-message", "System", "'"+ parsed.data + "'' is very close.")
        } else if (parsed.type === "update-wordhint") {
            applyWordHints(parsed.data);
        } else if (parsed.type === "message") {
            applyMessage("", parsed.data.author, parsed.data.content);
        } else if (parsed.type === "system-message") {
            applyMessage("system-message", "System", parsed.data);
        } else if (parsed.type === "non-guessing-player-message") {
            applyMessage("correct-guess-message", parsed.data.author, parsed.data.content);
        } else if (parsed.type === "line") {
            drawLine(context, parsed.data.fromX * scaleDownFactor(), parsed.data.fromY * scaleDownFactor(), parsed.data.toX * scaleDownFactor(), parsed.data.toY * scaleDownFactor(), parsed.data.color, parsed.data.lineWidth * scaleDownFactor());
        } else if (parsed.type === "fill") {
            fill(context, parsed.data.x * scaleDownFactor(), parsed.data.y * scaleDownFactor(), parsed.data.color);
        } else if (parsed.type === "clear-drawing-board") {
            clear(context)
        } else if (parsed.type === "next-turn") {
            //As soon as a turn starts, the round should be ongoing, so we make
            //sure that all types of dialogs, that indicate the game isn't
            //ongoing, are not visible anymore.
            unstartedDialog.style.visibility = "hidden";
            startDialog.style.visibility = "hidden";
            restartButton.style.display = "none";
            gameOverDialog.style.visibility = "hidden";

            //If a player doesn't choose, the dialog will still be up.
            wordDialog.style.visibility = "hidden";
            playWav('/resources/end-turn.wav');

            clear(context);

            roundEndTime = parsed.data.roundEndTime;
            applyRounds(parsed.data.round, maxRounds);
            applyPlayers(parsed.data.players);

            //We clear this, since there's no word chosen right now.
            wordContainer.innerHTML = "";

            if (parsed.data.previousWord !== null) {
                if (parsed.data.previousWord === "") {
                    applyMessage("system-message", "System", "Round over. No word was chosen.");
                } else {
                    applyMessage("system-message", "System", "Round over. Previous word was '"+parsed.data.previousWord+"'");
                }
            }

            allowDrawing = false;
        } else if (parsed.type === "your-turn") {
            playWav('/resources/your-turn.wav');

            promptWords(parsed.data[0], parsed.data[1], parsed.data[2]);
        } else if (parsed.type === "drawing") {
            applyDrawData(parsed.data)
        } else if (parsed.type === "kick-vote") {
            if (parsed.data.playerId !== ownID) {
                applyMessage("system-message", "System", "("+parsed.data.voteCount+"/"+parsed.data.requiredVoteCount+") players voted to kick "+parsed.data.playerName+".")
                if (parsed.data.voteCount >= parsed.data.requiredVoteCount) {
                    applyMessage("system-message", "System", parsed.data.playerName+" has been kicked.")
                }
            }
        }
    };

    function getPlayer(playerID) {
        for (let i = 0; i < cachedPlayers.length; i++) {
            let player = cachedPlayers[i];
            if (player.id === playerID) {
                return player;
            }
        }

        return null;
    }

    function handleReadyEvent(ready) {
        ownerID = ready.ownerId;
        ownName = ready.playerName;
        allowDrawing = ready.allowDrawing;
        ownID = ready.playerId;
        maxRounds = ready.maxRounds;
        roundEndTime = ready.roundEndTime;
        votekickEnabled = ready.votekickEnabled;
        applyRounds(ready.round, ready.maxRounds);

        if (ready.players && ready.players.length) {
            applyPlayers(ready.players)
        }
        if (ready.currentDrawing && ready.currentDrawing.length) {
            applyDrawData(ready.currentDrawing)
        }
        if (ready.wordHints && ready.wordHints.length) {
            applyWordHints(ready.wordHints)
        }
    }

    function promptWords(wordOne, wordTwo, wordThree) {
        wordButtonZero.textContent = wordOne;
        wordButtonOne.textContent = wordTwo;
        wordButtonTwo.textContent = wordThree;
        wordDialog.style.visibility = "visible";
    }

    function playWav(file) {
        if (sound) {
            let audio = new Audio(file);
            audio.type = 'audio/wav';
            audio.play();
        }
    }

    window.setInterval(function () {
        if (roundEndTime >= 0) {
            timeLeft.innerText = "Time Left: " + Math.floor(roundEndTime / 1000);
            roundEndTime -= 500;
        } else {
            timeLeft.innerText = "Time Left: ∞";
        }
    }, 500);

    function applyMessage(styleClass, author, message) {
        if (messageContainer.childElementCount >= 100) {
            messageContainer.removeChild(messageContainer.firstChild)
        }

        messageContainer.innerHTML += `<div class="message ` + styleClass + `">
                            <span class="chat-name">` + author + `</span>
                            <span class="message-content">` + message + `</span>
                        </div>`;
    }

    let cachedPlayers;

    function applyPlayers(players) {
        playerContainer.innerHTML = "";
        cachedPlayers = players;
        players.forEach(function (player) {
            //We don't wanna show the disconnected players.
            if (!player.connected) {
                return;
            }

            //We simply abuse the player events to get our latest name, since there's no separate event for this.
            if (player.id === ownID) {
                ownName = player.name;
            }

            let stateStyleClass;
            if (player.state === "standby") {
                stateStyleClass = 'player-done';
            } else {
                stateStyleClass = '';
            }
            let newPlayerElement = '<div class="player ' + stateStyleClass + '">' +
                '<span class="rank">' + player.rank + '</span>' +
                '<span class="playername';
            if (player.id === ownID) {
                newPlayerElement += ' playername-self';
            }
            newPlayerElement +=
                '">' + player.name + '</span>' +
                '<div class="score-and-status">' +
                '<div>' +
                '<span class="playerscore">' + player.score + '</span>' +
                '<span class="last-turn-score">(Last turn: ' + player.lastScore + ')</span>' +
                '</div>';
            if (player.state === "drawing") {
                newPlayerElement += '<span>✏️</span>';
            } else if (player.state === "standby") {
                newPlayerElement += '<span>✔️</span>';
            }
            newPlayerElement += '</div></div>';
            playerContainer.innerHTML += newPlayerElement;
        });
    }

    function applyRounds(round, maxRound) {
        roundsSpan.innerText = 'Round ' + round + ' of ' + maxRound;
    }

    function applyWordHints(wordHints) {
        wordContainer.innerHTML = "";
        //If no hint has been revealed
        wordHints.forEach(function (hint) {
            if (hint.character === 0) {
                wordContainer.innerHTML += '<span class="guess-letter guess-letter-underline">&nbsp;</span>';
            } else {
                let char = String.fromCharCode(hint.character);
                if (hint.underline) {
                    wordContainer.innerHTML += '<span class="guess-letter guess-letter-underline">' + char + '</span>'
                } else {
                    wordContainer.innerHTML += '<span class="guess-letter">' + char + '</span>';
                }
            }
        });
    }

    function applyDrawData(drawElements) {
        clear(context);
        drawElements.forEach(function (drawElement) {
            let drawData = drawElement.data;
            if (drawElement.type === "fill") {
                fill(context, drawData.x * scaleDownFactor(), drawData.y * scaleDownFactor(), drawData.color);
            } else if (drawElement.type === "line") {
                drawLine(context, drawData.fromX * scaleDownFactor(), drawData.fromY * scaleDownFactor(), drawData.toX * scaleDownFactor(), drawData.toY * scaleDownFactor(), drawData.color, drawData.lineWidth * scaleDownFactor());
            } else {
                console.log("Unknown draw element type: " + drawData.type)
            }
        });
    }

    let isDrawing = false;
    let x = 0;
    let y = 0;

    // Touch input
    let touchID = 0;

    drawingBoard.ontouchstart = function (e) {
        if (!isDrawing && allowDrawing) {
            touchID = e.touches[0].identifier;

            if (allowDrawing && localTool !== 2) {
                // calculate the offset coordinates based on client touch position and drawing board client origin
                let clientRect = drawingBoard.getBoundingClientRect();
                x = (e.touches[0].clientX - clientRect.left);
                y = (e.touches[0].clientY - clientRect.top);

                isDrawing = true;
            }
        }
    };

    drawingBoard.ontouchmove = function (e) {
        //FIXME Explanation? Does this prevent moving the page?
        e.preventDefault();

        if (allowDrawing && isDrawing) {
            // find touch with correct ID
            for (let i = e.changedTouches.length - 1; i >= 0; i--) {
                if (e.changedTouches[i].identifier === touchID) {
                    let touch = e.changedTouches[i];

                    // calculate the offset coordinates based on client touch position and drawing board client origin
                    let clientRect = drawingBoard.getBoundingClientRect();
                    let offsetX = (touch.clientX - clientRect.left);
                    let offsetY = (touch.clientY - clientRect.top);

                    // drawing functions must check for context boundaries
                    drawLineAndSendEvent(context, x, y, offsetX, offsetY, localColor, localLineWidth);
                    x = offsetX;
                    y = offsetY;

                    return;
                }
            }
        }
    };

    function onTouchEnd(e) {
        if (isDrawing) {
            // find touch with correct ID
            for (let i = e.changedTouches.length - 1; i >= 0; i--) {
                if (e.changedTouches[i].identifier === touchID) {
                    isDrawing = false;
                    return;
                }
            }
        }
    }

    drawingBoard.ontouchend = onTouchEnd;
    drawingBoard.ontouchcancel = onTouchEnd;

    // Mouse input
    drawingBoard.onmousedown = function (e) {
        if (allowDrawing && e.button === 0 && localTool !== 2) {
            let clientRect = drawingBoard.getBoundingClientRect();
            x = e.clientX - clientRect.left;
            y = e.clientY - clientRect.top;

            isDrawing = true;
        }

        return false;
    };

    // This is executed even if the mouse is not above the browser anymore.
    window.onmouseup = function (e) {
        if (isDrawing === true) {
            isDrawing = false;
        }
    };

    function mouseUpdate(e) {
        if (allowDrawing && isDrawing === true && e.button === 0) {
            // calculate the offset coordinates based on client mouse position and drawing board client origin
            let clientRect = drawingBoard.getBoundingClientRect();
            let offsetX = (e.clientX - clientRect.left);
            let offsetY = (e.clientY - clientRect.top);

            // drawing functions must check for context boundaries
            drawLineAndSendEvent(context, x, y, offsetX, offsetY, localColor, localLineWidth);
            x = offsetX;
            y = offsetY;
        }
    }

    drawingBoard.onmousemove = mouseUpdate;
    drawingBoard.onmouseleave = mouseUpdate;

    // necessary for mousemove to not use the previous exit coordinates.
    window.onmousemove = function (e) {
        let clientRect = drawingBoard.getBoundingClientRect();
        x = Math.min(clientRect.width - 1, Math.max(0, e.clientX - clientRect.left));
        y = Math.min(clientRect.height - 1, Math.max(0, e.clientY - clientRect.top));
    };

    drawingBoard.onclick = function (e) {
        if (allowDrawing && e.button === 0) {
            if (localTool === 2) {
                fillAndSendEvent(context, e.offsetX, e.offsetY, localColor)
            } else {
                drawLineAndSendEvent(context, e.offsetX, e.offsetY, e.offsetX, e.offsetY, localColor, localLineWidth);
            }
            isDrawing = false;
        }
    };

    function clear(context) {
        context.fillStyle = "#FFFFFF";
        context.fillRect(0, 0, drawingBoard.width, drawingBoard.height);
    }

    function fill(context, x1, y1, color) {
        context.fillStyle = color;
        //There seems to be some bug where setting the tolerance to 0 causes a freeze when painting black on white.
        context.fillFlood(x1, y1, 1);
    }

    function fillAndSendEvent(context, x1, y1, color) {
        fill(context, x1, y1, color);
        let fillInstruction = {
            type: "fill",
            data: {
                x: x1 * scaleUpFactor(),
                y: y1 * scaleUpFactor(),
                color: color
            },
        };
        socket.send(JSON.stringify(fillInstruction));
    }

    function drawLineAndSendEvent(context, x1, y1, x2, y2, color, lineWidth) {
        if (localTool === 1) {
            color = "#ffffff";
        }

        drawLine(context, x1, y1, x2, y2, color, lineWidth);

        let drawInstruction = {
            type: "line",
            data: {
                fromX: x1 * scaleUpFactor(),
                fromY: y1 * scaleUpFactor(),
                toX: x2 * scaleUpFactor(),
                toY: y2 * scaleUpFactor(),
                color: color,
                lineWidth: lineWidth * scaleUpFactor(),
            }
        };
        socket.send(JSON.stringify(drawInstruction));
    }

    function drawLine(context, x1, y1, x2, y2, color, lineWidth) {
        // the coordinates must be whole numbers to improve performance.
        // also, decimals as coordinates is not making sense.
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
        lineWidth = Math.ceil(lineWidth);

        // calculate bounding box
        let left = Math.max(0, Math.min(context.canvas.width, Math.min(x1, x2) - lineWidth));
        let top = Math.max(0, Math.min(context.canvas.height, Math.min(y1, y2) - lineWidth));
        let right = Math.max(0, Math.min(context.canvas.width, Math.max(x1, x2) + lineWidth));
        let bottom = Math.max(0, Math.min(context.canvas.height, Math.max(y1, y2) + lineWidth));

        // off canvas, so don't draw anything
        if (right - left === 0 || bottom - top === 0) {
            return;
        }

        color = hexToRgb(color);
        color[3] = 255; //alpha channel

        const circleMap = generateCircleMap(Math.floor(lineWidth / 2));
        const offset = Math.floor(circleMap.length / 2);

        const imageData = context.getImageData(left, top, right - left, bottom - top);

        for (let ix = 0; ix < circleMap.length; ix++) {
            for (let iy = 0; iy < circleMap[ix].length; iy++) {
                if (circleMap[ix][iy] === 1 || (x1 === x2 && y1 === y2 && circleMap[ix][iy] === 2)) {
                    const newX1 = x1 + ix - offset - left;
                    const newY1 = y1 + iy - offset - top;
                    const newX2 = x2 + ix - offset - left;
                    const newY2 = y2 + iy - offset - top;
                    drawBresenhamLine(imageData, newX1, newY1, newX2, newY2, color);
                }
            }
        }
        context.putImageData(imageData, left, top);
    }

    function drawBresenhamLine(imageData, x0, y0, x1, y1, color) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;

        while (true) {
            //check if pixel is inside the canvas
            if (!(x0 < 0 || x0 >= imageData.width || y0 < 0 || y0 >= imageData.height)) {
                setPixel(imageData, x0, y0, color);
            }


            if ((x0 === x1) && (y0 === y1)) break;
            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                err += dx;
                y0 += sy;
            }
        }
    }

    function generateCircleMap(radius) {
        let circleData = [];

        for (x = 0; x < 2 * radius; x++) {
            circleData[x] = [];
            for (y = 0; y < 2 * radius; y++) {
                const distanceToRadius = Math.sqrt(Math.pow(radius - x, 2) + Math.pow(radius - y, 2));
                if (distanceToRadius > radius) {
                    circleData[x][y] = 0;
                } else if (distanceToRadius < radius - 2) {
                    //optimize for performance: fill circle only when mouse was not moved
                    circleData[x][y] = 2;
                } else {
                    circleData[x][y] = 1;
                }
            }
        }

        return circleData;
    }

    function setPixel(imageData, x, y, color) {
        const offset = (y * imageData.width + x) * 4;
        imageData.data[offset] = color[0];
        imageData.data[offset + 1] = color[1];
        imageData.data[offset + 2] = color[2];
        imageData.data[offset + 3] = color[3];
    }

    //Call intially to correct initial state
    handleCanvasResize();
    window.addEventListener("resize", () => {
        handleCanvasResize();
        //Since the canvas gets cleared, we request the drawing again.
        //Saving it locally would be wasteful and might slow down some
        //clients due to a lot of memory allocation.
        socket.send(JSON.stringify({
            type: "request-drawing",
        }));
    }, false);

</script>
</body>

</html>
