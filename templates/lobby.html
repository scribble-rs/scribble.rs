<!DOCTYPE html>
<html lang="en">

<head>
    <title>Scribble.rs - Game</title>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/resources/style.css"/>
    <link rel="stylesheet" type="text/css" href="/resources/lobby.css"/>
    <link rel="stylesheet" type="text/css" href="/resources/lobby_players.css"/>
    <link rel="icon" type="image/png" href="/resources/favicon.png"/>
</head>

<body>
<noscript><span class="noscript">Hey, seems like you've disabled JavaScript.
            I get it ... but you are trying to play an interactive drawing game
            here, so you have to turn on JavaScript.</span></noscript>
<div id="word-dialog">
    <span class="word-dialog-text">Choose a word</span>
    <div class="word-button-container">
        <button id="word-button-zero" class="word-button" onclick="chooseWord(0)">Placeholder</button>
        <button id="word-button-one" class="word-button" onclick="chooseWord(1)">Placeholder</button>
        <button id="word-button-two" class="word-button" onclick="chooseWord(2)">Placeholder</button>
    </div>
</div>
<div class="content-wrapper">
    <div id="lobby">
        <div id="top-left-cell">
            <span id="rounds">Round {{.Round}} of {{.Rounds}}</span>
            <label for="sound-toggle">
                <input class="custom-check-or-radio sound-toggle-input" type="checkbox" name="sound-toggle"
                       onchange="toggleSound()"/>
                <span id="sound-toggle-label"></span>
            </label>
        </div>
        <div id="word-container"></div>
        <span id="time-left">Time Left: ‚àû</span>

        <div id="player-container">
        </div>

        <div id="drawing-board-wrapper">
            <canvas id="drawing-board"></canvas>
        </div>

        <div id="chat">
            <div id="message-container">
                <b>Type !start to begin the round or change your name with !nick.</b>
            </div>
            <form class="message-input-form" onsubmit="return sendMessage()">
                <input id="message-input" type="text" autocomplete="off" placeholder="Type your message"/>
            </form>
        </div>
        <div id="toolbox">
            <input class="toolbox-group" type="color" id="color-picker" onchange="setColor()" value="#000000"
                   alt="Current color (Click to change)" title="Current color (Click to change)">
            <div class="color-button-container toolbox-group">
                <div class="color-button-row">
                    <button class="color-button" style="background-color: #ffffff"
                            onclick="setColor('#ffffff')"></button>
                    <button class="color-button" style="background-color: #c1c1c1"
                            onclick="setColor('#c1c1c1')"></button>
                    <button class="color-button" style="background-color: #ef130b"
                            onclick="setColor('#ef130b')"></button>
                    <button class="color-button" style="background-color: #ff7100"
                            onclick="setColor('#ff7100')"></button>
                    <button class="color-button" style="background-color: #ffe400"
                            onclick="setColor('#ffe400')"></button>
                    <button class="color-button" style="background-color: #00cc00"
                            onclick="setColor('#00cc00')"></button>
                    <button class="color-button" style="background-color: #00b2ff"
                            onclick="setColor('#00b2ff')"></button>
                    <button class="color-button" style="background-color: #231fd3"
                            onclick="setColor('#231fd3')"></button>
                    <button class="color-button" style="background-color: #a300ba"
                            onclick="setColor('#a300ba')"></button>
                    <button class="color-button" style="background-color: #d37caa"
                            onclick="setColor('#d37caa')"></button>
                    <button class="color-button" style="background-color: #a0522d"
                            onclick="setColor('#a0522d')"></button>
                </div>
                <div class="color-button-row">
                    <button class="color-button" style="background-color: #000000"
                            onclick="setColor('#000000')"></button>
                    <button class="color-button" style="background-color: #4c4c4c"
                            onclick="setColor('#4c4c4c')"></button>
                    <button class="color-button" style="background-color: #740b07"
                            onclick="setColor('#740b07')"></button>
                    <button class="color-button" style="background-color: #c23800"
                            onclick="setColor('#c23800')"></button>
                    <button class="color-button" style="background-color: #e8a200"
                            onclick="setColor('#e8a200')"></button>
                    <button class="color-button" style="background-color: #005510"
                            onclick="setColor('#005510')"></button>
                    <button class="color-button" style="background-color: #00569e"
                            onclick="setColor('#00569e')"></button>
                    <button class="color-button" style="background-color: #0e0865"
                            onclick="setColor('#0e0865')"></button>
                    <button class="color-button" style="background-color: #550069"
                            onclick="setColor('#550069')"></button>
                    <button class="color-button" style="background-color: #a75574"
                            onclick="setColor('#a75574')"></button>
                    <button class="color-button" style="background-color: #63300d"
                            onclick="setColor('#63300d')"></button>
                </div>
            </div>
            <div class="pencil-sizes-container toolbox-group">
                <label for="tool-type-pencil">
                    <input id="tool-type-pencil" class="custom-check-or-radio line-width-button"
                           onchange="chooseTool(0)" type="radio" name="tool-type" checked>
                    <div class="line-width-button-content">
                        <span id="tool-type-pencil-button" style="font-size: 2rem;">‚úèÔ∏è</span>
                    </div>
                </label>
                <label for="tool-type-fill">
                    <input id="tool-type-fill" class="custom-check-or-radio line-width-button"
                           onchange="chooseTool(2)" type="radio" name="tool-type">
                    <div class="line-width-button-content">
                        <img alt="Fill" title="Fill tool" src="/resources/fill.svg" width="40px"
                             height="40px"/>
                    </div>
                </label>
                <label for="tool-type-rubber">
                    <input id="tool-type-rubber" class="custom-check-or-radio line-width-button"
                           onchange="chooseTool(1)" type="radio" name="tool-type">
                    <div class="line-width-button-content">
                        <img alt="Rubber" title="Rubber tool" src="/resources/rubber.svg" width="40px"
                             height="40px"/>
                    </div>
                </label>
            </div>
            <div class="pencil-sizes-container toolbox-group">
                <label for="size8">
                    <input id="size8" class="custom-check-or-radio line-width-button" onchange="setLineWidth(8)"
                           type="radio" name="line-width" checked>
                    <div class="line-width-button-content">
                        <div id="size-8-button" class="dot"></div>
                    </div>
                </label>
                <label for="size15">
                    <input id="size15" class="custom-check-or-radio line-width-button" onchange="setLineWidth(15)"
                           type="radio" name="line-width">
                    <div class="line-width-button-content">
                        <div id="size-15-button" class="dot"></div>
                    </div>
                </label>
                <label for="size30">
                    <input id="size30" class="custom-check-or-radio line-width-button" onchange="setLineWidth(30)"
                           type="radio" name="line-width">
                    <div class="line-width-button-content">
                        <div id="size-30-button" class="dot"></div>
                    </div>
                </label>
                <label for="size40">
                    <input id="size40" class="custom-check-or-radio line-width-button" onchange="setLineWidth(40)"
                           type="radio" name="line-width">
                    <div class="line-width-button-content">
                        <div id="size-40-button" class="dot"></div>
                    </div>
                </label>
            </div>
            <button class="canvas-button toolbox-group" style="font-size: 2rem;" onclick="clearCanvasAndSendEvent()"
                    alt="Clear the canvas" title="Clear the canvas">üóë
            </button>
        </div>
    </div>
</div>

{{template "footer"}}

<script type="text/javascript" src="/resources/floodfill.js"></script>
<script type="text/javascript">
    console.log("Attempting Connection on port " + location.port + "...");
    let socket
    if (location.protocol === 'https:') {
        socket = new WebSocket("wss://" + location.hostname + ":" + location.port + "/ws?id={{.LobbyID}}");
    } else {
        socket = new WebSocket("ws://" + location.hostname + ":" + location.port + "/ws?id={{.LobbyID}}");
    }

    const messageInput = document.getElementById("message-input");
    const playerContainer = document.getElementById("player-container");
    const wordContainer = document.getElementById("word-container");
    const messageContainer = document.getElementById("message-container");
    const roundsSpan = document.getElementById("rounds");
    const timeLeft = document.getElementById("time-left");
    const drawingBoard = document.getElementById("drawing-board");
    const colorPicker = document.getElementById("color-picker");
    const lineWidthChooser = document.getElementById("line-width");
    const wordDialog = document.getElementById("word-dialog");
    const wordButtonZero = document.getElementById("word-button-zero");
    const wordButtonOne = document.getElementById("word-button-one");
    const wordButtonTwo = document.getElementById("word-button-two");

    const noSoundIcon = "üîá";
    const soundIcon = "üîä";
    const soundToggleLabel = document.getElementById("sound-toggle-label");
    let sound;
    if (localStorage.getItem("sound") === "false") {
        sound = false;
        soundToggleLabel.innerText = noSoundIcon;
    } else {
        sound = true;
        soundToggleLabel.innerText = soundIcon;
    }

    function toggleSound() {
        if (sound) {
            localStorage.setItem("sound", "false");
            sound = false;
            soundToggleLabel.innerText = noSoundIcon;
        } else {
            localStorage.setItem("sound", "true");
            sound = true;
            soundToggleLabel.innerText = soundIcon;
        }
    }

    function getWindowScale() {
        if ('devicePixelRatio' in window) {
            return window.devicePixelRatio;
        } else {
            return 1;
        }
    }

    // Drawing board ratio
    const boardRatio = 16 / 9;

    // Window scale
    const windowScale = getWindowScale();

    // Reverted for now: Have the drawing board coordinates normalized to 1 unit of width and the ratio based unit of height.
    const baseWidth = 1461; //1;
    const baseHeight = 821; //baseWidth / boardRatio;

    //FIXME Disgusting trick to fix the layout, css didn't do it for me.
    document.getElementById("chat").style.maxHeight = (document.getElementById("drawing-board-wrapper").clientWidth) / boardRatio + "px";
    drawingBoard.style.maxWidth = Math.round(document.getElementById("drawing-board-wrapper").clientWidth) + "px";
    drawingBoard.style.maxHeight = Math.round((document.getElementById("drawing-board-wrapper").clientWidth) / boardRatio) + "px";

    // Set drawingBoard pixel resolution
    // Mind the window scale to get sharp drawing on HiDPI devices (Retina Display etc.)
    drawingBoard.width = Math.round(document.getElementById("drawing-board-wrapper").clientWidth) * windowScale;
    drawingBoard.height = Math.round(document.getElementById("drawing-board-wrapper").clientWidth) / boardRatio * windowScale;

    // Moving this here to extract the context after resizing
    const context = drawingBoard.getContext("2d");
    context.lineJoin = "round";

    const scaleUpFactor = baseWidth / drawingBoard.width;
    const scaleDownFactor = drawingBoard.width / baseWidth;

    let allowDrawing = false;
    let localColor = "#000000";
    let localLineWidth;
    // 0 = pencil; 1 = rubber; 2 = fill
    let localTool = 0;
    setLineWidth(5);

    document.getElementById("size-8-button").style.width = (8 * scaleDownFactor) + "px";
    document.getElementById("size-8-button").style.height = (8 * scaleDownFactor) + "px";
    document.getElementById("size-15-button").style.width = (15 * scaleDownFactor) + "px";
    document.getElementById("size-15-button").style.height = (15 * scaleDownFactor) + "px";
    document.getElementById("size-30-button").style.width = (30 * scaleDownFactor) + "px";
    document.getElementById("size-30-button").style.height = (30 * scaleDownFactor) + "px";
    document.getElementById("size-40-button").style.width = (40 * scaleDownFactor) + "px";
    document.getElementById("size-40-button").style.height = (40 * scaleDownFactor) + "px";

    function setColor(value) {
        if (value === undefined) {
            localColor = colorPicker.value;
        } else {
            localColor = value;
            colorPicker.value = value;
        }
        updateCursor();
    }

    function setLineWidth(value) {
        localLineWidth = value * scaleDownFactor;
        updateCursor();
    }

    function chooseTool(value) {
        if (value === 1) {
            localTool = 1;
        } else if (value === 2) {
            localTool = 2;
        } else {
            //Everything not Rubber or Fill Bucket is a pencil.
            localTool = 0;
        }
    }

    function hexToRgb(hex) {
        return hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => '#' + r + r + g + g + b + b)
            .substring(1).match(/.{2}/g)
            .map(x => parseInt(x, 16));
    }

    function updateCursor() {
        let cursorColor;
        let borderColor = "white";
        if (localColor.startsWith("#")) {
            cursorColor = hexToRgb(localColor);

            const hsp = Math.sqrt(
                0.299 * (cursorColor[0] * cursorColor[0]) +
                0.587 * (cursorColor[1] * cursorColor[1]) +
                0.114 * (cursorColor[2] * cursorColor[2])
            );

            if (hsp > 127.5) {
                borderColor = "rgb(0,0,0)";
            } else {
                borderColor = "rgb(255,255,255)";
            }

            cursorColor = "rgb(" + cursorColor[0] + "," + cursorColor[1] + "," + cursorColor[2] + ")";
        } else {
            cursorColor = localColor;
        }

        drawingBoard.style.cursor = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"" + (localLineWidth + 2) + "\" height=\"" + (localLineWidth + 2) + "\"><circle cx=\"" + (localLineWidth / 2) + "\" cy=\"" + (localLineWidth / 2) + "\" r=\"" + (localLineWidth / 2) + "\" style=\"fill: " + cursorColor + "; stroke: " + borderColor + ";\"/></svg>') " + (localLineWidth / 2) + " " + (localLineWidth / 2) + ", auto";
    }

    function clearCanvasAndSendEvent() {
        //Avoid unnecessary traffoc back to us.
        clear(context);
        socket.send(JSON.stringify({
            type: "clear-drawing-board"
        }));
    }

    const sendMessage = () => {
        socket.send(JSON.stringify({
            type: "message",
            data: messageInput.value
        }));
        messageInput.value = "";

        // Necessary in order to keep the page from submitting.
        return false;
    };

    function chooseWord(index) {
        socket.send(JSON.stringify({
            type: "choose-word",
            data: index
        }));
        wordDialog.style.visibility = "hidden";
    }

    function onClickKickButton(playerId) {
        socket.send(JSON.stringify({
            type: "kick-vote",
            data: playerId
        }));
    }

    new MutationObserver(
        () => {
            messageContainer.scrollTop = messageContainer.scrollHeight;
        }
    ).observe(messageContainer, {
        attributes: false,
        childList: true,
        subtree: false
    });

    socket.onopen = () => {
        console.log("Successfully Connected");
    };

    socket.onmessage = event => {
        let parsed = JSON.parse(event.data);
        if (parsed.type === "update-players") {
            playerContainer.innerHTML = "";
            parsed.data.forEach(function (player) {
                let stateStyleClass;
                if (player.state === 2) {
                    stateStyleClass = 'player-done';
                } else if (player.state === 3) {
                    stateStyleClass = 'player-disconnected';
                } else {
                    stateStyleClass = '';
                }
                let newPlayerElement = '<div class="player ' + stateStyleClass + '">' +
                    '<span class="rank">' + player.rank + '</span>' +
                    '<div class="name-and-buttons">' +
                    '<span class="playername">' + player.name + '</span>' +
                    '<button class="kick-button" id="kick-button" type="button" title="Vote to kick this player" alt="Vote to kick this player" onclick="onClickKickButton(' + player.id + ')">üëã</button>' +
                    '</div>' +
                    '<div class="score-and-status">' +
                    '<div>' +
                    '<span class="playerscore">' + player.score + '</span>' +
                    '<span class="last-turn-score">(Last turn: ' + player.lastScore + ')</span>' +
                    '</div>';
                if (player.state === 1) {
                    newPlayerElement += '<span>‚úèÔ∏è</span>';
                } else if (player.state === 2) {
                    newPlayerElement += '<span>‚úîÔ∏è</span>';
                }
                newPlayerElement += '</div></div>';
                playerContainer.innerHTML += newPlayerElement;
            });
        } else if (parsed.type === "correct-guess") {
            if (sound) {
                let audio = new Audio('/resources/plop.wav');
                audio.type = 'audio/wav';

                audio.play();
            }
        } else if (parsed.type === "update-wordhint") {
            wordContainer.innerHTML = "";
            //If no hint has been revelaed
            parsed.data.forEach(function (hint) {
                if (hint.character === 0) {
                    wordContainer.innerHTML += '<span class="guess-letter guess-letter-underline">&nbsp;</span>';
                } else {
                    let char = String.fromCharCode(hint.character);
                    if (hint.underline) {
                        wordContainer.innerHTML += '<span class="guess-letter guess-letter-underline">' + char + '</span>'
                    } else {
                        wordContainer.innerHTML += '<span class="guess-letter">' + char + '</span>';
                    }
                }
            });
        } else if (parsed.type === "update-rounds") {
            roundsSpan.innerText = 'Round ' + parsed.data.current + ' of ' + parsed.data.max;
        } else if (parsed.type === "message") {
            if (messageContainer.childElementCount >= 100) {
                messageContainer.removeChild(messageContainer.firstChild)
            }

            messageContainer.innerHTML += `<div class="message">
                            <span class="chat-name">` + parsed.data.Author + `</span>
                            <span class="message-content">` + parsed.data.Content + `</span>
                        </div>`;
        } else if (parsed.type === "system-message") {
            if (messageContainer.childElementCount >= 100) {
                messageContainer.removeChild(messageContainer.firstChild)
            }

            messageContainer.innerHTML += `<div class="message system-message">
                            <span class="chat-name">System</span>
                            <span class="message-content">` + parsed.data + `</span>
                        </div>`;
        } else if (parsed.type === "non-guessing-player-message") {
            messageContainer.innerHTML += `<div class="non-guessing-player-message">
                            <span class="chat-name">` + parsed.data.Author + `</span>
                            <span class="message-content">` + parsed.data.Content + `</span>
                        </div>`;
        } else if (parsed.type === "persist-username") {
            //TODO GMT date for consistency?
            document.cookie = "username=" + parsed.data + ";expires=Tue, 19 Jan 2038 03:14:07 UTC;path=/;samesite=strict";
        } else if (parsed.type === "reset-username") {
            document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
        } else if (parsed.type === "line") {
            drawLine(context, parsed.data.fromX * scaleDownFactor, parsed.data.fromY * scaleDownFactor, parsed.data.toX * scaleDownFactor, parsed.data.toY * scaleDownFactor, parsed.data.color, parsed.data.lineWidth * scaleDownFactor);
        } else if (parsed.type === "fill") {
            fill(context, parsed.data.x * scaleDownFactor, parsed.data.y * scaleDownFactor, parsed.data.color);
        } else if (parsed.type === "set-canvas") {
            clear(context);
            parsed.data.forEach(function (drawElement) {
                if (drawElement.type === "fill") {
                    fill(context, drawElement.x * scaleDownFactor, drawElement.y * scaleDownFactor, drawElement.color);
                } else if (drawElement.type = "line") {
                    drawLine(context, drawElement.fromX * scaleDownFactor, drawElement.fromY * scaleDownFactor, drawElement.toX * scaleDownFactor, drawElement.toY * scaleDownFactor, drawElement.color, drawElement.lineWidth * scaleDownFactor);
                } else {
                    console.log("Unknown draw element type: " + drawElement.type)
                }
            });
        } else if (parsed.type === "clear-drawing-board") {
            clear(context)
        } else if (parsed.type === "next-turn") {
            if (sound) {
                let audio = new Audio('/resources/end-turn.wav');
                audio.type = 'audio/wav';
                audio.play();
            }

            clear(context)

            allowDrawing = false;
        } else if (parsed.type === "your-turn") {
            allowDrawing = true;
        } else if (parsed.type === "update-time") {
            timeLeft.innerText = "Time Left: " + parsed.data;
        } else if (parsed.type === "prompt-words") {
            if (sound) {
                let audio = new Audio('/resources/your-turn.wav');
                audio.type = 'audio/wav';

                audio.play();
            }

            wordButtonZero.textContent = parsed.data[0];
            wordButtonOne.textContent = parsed.data[1];
            wordButtonTwo.textContent = parsed.data[2];
            wordDialog.style.visibility = "visible";
        }
    };

    socket.onclose = event => console.log("Socket Closed Connection: ", event);
    socket.onerror = error => console.log("Socket Error: ", error);

    let isDrawing = false;
    let x = 0;
    let y = 0;

    // Touch input
    let touchID = 0;

    drawingBoard.ontouchstart = function (e) {
        if (!isDrawing && allowDrawing) {
            console.log(e.touches.length)
            touchID = e.touches[0].identifier;

            if (allowDrawing && localTool !== 2) {
                // calculate the offset coordinates based on client touch position and drawing board client origin
                let clientRect = drawingBoard.getBoundingClientRect();
                x = (e.touches[0].clientX - clientRect.left);
                y = (e.touches[0].clientY - clientRect.top);

                isDrawing = true;
            }
        }
    };

    drawingBoard.ontouchmove = function (e) {
        //FIXME Explanation? Does this prevent moving the page?
        e.preventDefault();

        if (isDrawing) {
            // find touch with correct ID
            for (let i = e.changedTouches.length - 1; i >= 0; i--) {
                if (e.changedTouches[i].identifier === touchID) {
                    let touch = e.changedTouches[i];

                    // calculate the offset coordinates based on client touch position and drawing board client origin
                    let clientRect = drawingBoard.getBoundingClientRect();
                    let offsetX = (touch.clientX - clientRect.left);
                    let offsetY = (touch.clientY - clientRect.top);

                    // drawing functions must check for context boundaries
                    drawLineAndSendEvent(context, x, y, offsetX, offsetY, localColor, localLineWidth);
                    x = offsetX;
                    y = offsetY;

                    return;
                }
            }
        }
    };

    function onTouchEnd(e) {
        if (isDrawing) {
            // find touch with correct ID
            for (let i = e.changedTouches.length - 1; i >= 0; i--) {
                if (e.changedTouches[i].identifier === touchID) {
                    isDrawing = false;
                    return;
                }
            }
        }
    }

    drawingBoard.ontouchend = onTouchEnd;
    drawingBoard.ontouchcancel = onTouchEnd;

    // Mouse input
    drawingBoard.onmousedown = function (e) {
        if (allowDrawing && e.button === 0 && localTool !== 2) {
            x = e.offsetX;
            y = e.offsetY;

            isDrawing = true;
        }

        return false;
    };

    // This is executed even if the mouse is not above the browser anymore.
    window.onmouseup = function (e) {
        if (isDrawing === true) {
            isDrawing = false;
        }
    };

    drawingBoard.onmousemove = function (e) {
        if (allowDrawing && isDrawing === true && e.button === 0) {
            // calculate the offset coordinates based on client mouse position and drawing board client origin
            let clientRect = drawingBoard.getBoundingClientRect();
            let offsetX = (e.clientX - clientRect.left);
            let offsetY = (e.clientY - clientRect.top);

            // drawing functions must check for context boundaries
            drawLineAndSendEvent(context, x, y, offsetX, offsetY, localColor, localLineWidth);
            x = offsetX;
            y = offsetY;
        }
    };

    // necessary for mousemove to not use the previous exit coordinates.
    drawingBoard.onmouseenter = function (e) {
        x = e.offsetX;
        y = e.offsetY;
    };

    drawingBoard.onclick = function (e) {
        if (allowDrawing && e.button === 0) {
            if (localTool === 2) {
                fillAndSendEvent(context, e.offsetX, e.offsetY, localColor)
            } else {
                drawLineAndSendEvent(context, e.offsetX, e.offsetY, e.offsetX, e.offsetY, localColor, localLineWidth);
            }
            isDrawing = false;
        }
    };

    function clear(context) {
        context.fillStyle = "#FFFFFF";
        context.fillRect(0, 0, drawingBoard.width, drawingBoard.height);
    }

    function fill(context, x1, y1, color) {
        context.fillStyle = color;
        //There seems to be some bug where setting the tolerance to 0 causes a freeze when painting black on white.
        // FIXME quick and dirty fix to apply the window scale to all drawing activities.
        context.fillFlood(x1 * windowScale, y1 * windowScale, 1);
    }

    function fillAndSendEvent(context, x1, y1, color) {
        fill(context, x1, y1, color);
        socket.send(JSON.stringify({
            type: "fill",
            data: {
                x: x1 * scaleUpFactor,
                y: y1 * scaleUpFactor,
                color: color
            },
        }));
    }

    function drawLineAndSendEvent(context, x1, y1, x2, y2, color, lineWidth) {
        if (localTool === 1) {
            color = "#ffffff";
        }

        drawLine(context, x1, y1, x2, y2, color, lineWidth);
        socket.send(JSON.stringify({
            type: "line",
            data: {
                fromX: x1 * scaleUpFactor,
                fromY: y1 * scaleUpFactor,
                toX: x2 * scaleUpFactor,
                toY: y2 * scaleUpFactor,
                color: color,
                lineWidth: lineWidth * scaleUpFactor,
            }
        }));
    }

    function drawLine(context, x1, y1, x2, y2, color, lineWidth) {
        // the coordinates must be whole numbers to improve performance.
        // also, decimals as coordinates is not making sense.
        // FIXME quick and dirty fix to apply the window scale to all drawing activities.
        x1 = Math.floor(x1 * windowScale);
        y1 = Math.floor(y1 * windowScale);
        x2 = Math.floor(x2 * windowScale);
        y2 = Math.floor(y2 * windowScale);
        lineWidth = Math.ceil(lineWidth);

        color = hexToRgb(color);
        color[3] = 255; //alpha channel


        let radius = Math.floor(lineWidth / 2);
        // calculate bounding box
        let left = Math.max(0, Math.min(x1, x2) - lineWidth);
        let top = Math.max(0, Math.min(y1, y2) - lineWidth);
        let right = Math.max(0, Math.min(context.canvas.width, Math.max(x1, x2) + lineWidth));
        let bottom = Math.max(0, Math.min(context.canvas.height, Math.max(y1, y2) + lineWidth));

        const imageData = context.getImageData(left, top, right - left, bottom - top);

        let circleMap = generateCircleMap(radius);
        for (let ix = 0; ix < circleMap.length; ix++) {
            for (let iy = 0; iy < circleMap[ix].length; iy++) {
                if (circleMap[ix][iy] === 1 || (x1 === x2 && y1 === y2 && circleMap[ix][iy] === 2)) {
                    const newX1 = x1 + ix - left - radius;
                    const newY1 = y1 + iy - top - radius;
                    const newX2 = x2 + ix - left - radius;
                    const newY2 = y2 + iy - top - radius;
                    drawBresenhamLine(imageData, newX1, newY1, newX2, newY2, color);
                }
            }
        }

        context.putImageData(imageData, left, top);
    }

    function drawBresenhamLine(imageData, x0, y0, x1, y1, color) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;

        while (true) {
            //check if pixel is inside the canvas
            if (x0 < 0 || x0 >= imageData.width || y0 < 0 || y0 >= imageData.height) return;
            setPixel(imageData, x0, y0, color);

            if ((x0 === x1) && (y0 === y1)) break;
            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                err += dx;
                y0 += sy;
            }
        }
    }

    function generateCircleMap(radius) {
        let circleData = [];

        for (x = 0; x < 2 * radius; x++) {
            circleData[x] = [];
            for (y = 0; y < 2 * radius; y++) {
                const distanceToRadius = Math.sqrt(Math.pow(radius - x, 2) + Math.pow(radius - y, 2));
                if (distanceToRadius > radius) {
                    circleData[x][y] = 0;
                } else if (distanceToRadius < radius - 2) {
                    //optimize for performance: fill circle only when mouse was not moved
                    circleData[x][y] = 2;
                } else {
                    circleData[x][y] = 1;
                }
            }
        }

        return circleData;
    }

    function setPixel(imageData, x, y, color) {
        const offset = (y * imageData.width + x) * 4;
        imageData.data[offset] = color[0];
        imageData.data[offset + 1] = color[1];
        imageData.data[offset + 2] = color[2];
        imageData.data[offset + 3] = color[3];
    }
</script>
</body>

</html>
