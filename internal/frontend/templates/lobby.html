{{define "lobby-page"}}
<!DOCTYPE html>
<html lang="{{.Locale}}">

<head>
    <title>Scribble.rs - Game</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75 maximum-scale=0.75, user-scalable=0">
    {{template "non-static-css-decl" .}}
    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/base.css?cache_bust={{.CacheBust}}" />
    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/lobby.css?cache_bust={{.CacheBust}}" />
    {{template "favicon-decl" .}}
</head>

<body>
    <div class="content-wrapper">
        <noscript><span class="noscript">{{.Translation.Get "requires-js"}}</span></noscript>

        <div id="lobby">
            <div id="lobby-header">
                <div id="round-container">
                    <span>{{.Translation.Get "round"}}&nbsp;</span>
                    <span id="rounds"></span>
                    <span id="max-rounds"></span>
                </div>

                <div id="lobby-header-center-element">
                    <div>
                        <!-- this button is basically behaving like a checkbox, but in order to
                    have a uniform look with the other buttons in the header, we are not using
                    a checkbox anymore. -->
                        <button onclick="toggleSound()" class="dialog-button header-button"
                            alt="{{.Translation.Get "toggle-soundeffects"}}"
                            title="{{.Translation.Get "toggle-soundeffects"}}">
                            <img id="sound-toggle-label" class="header-button-image" />
                        </button>
                        <button onclick="showNameChangeDialog()" class="dialog-button header-button"
                            alt="{{.Translation.Get "change-your-name"}}"
                            title="{{.Translation.Get "change-your-name"}}">
                            <img src="{{.RootPath}}/resources/user.svg?cache_bust={{.CacheBust}}"
                                class="header-button-image" />
                        </button>
                        <button onclick="toggleFullscreen()" class="dialog-button header-button"
                            alt="{{.Translation.Get "toggle-fullscreen"}}"
                            title="{{.Translation.Get "toggle-fullscreen"}}">
                            <img src="{{.RootPath}}/resources/fullscreen.svg?cache_bust={{.CacheBust}}"
                                class="header-button-image" />
                        </button>
                    </div>
                    <div id="word-container"></div>
                    <div>
                        <button id="help-button" onclick="showHelpDialog()" class="dialog-button header-button"
                            alt="{{.Translation.Get "show-help"}}" title="{{.Translation.Get "show-help"}}">
                            <img src="{{.RootPath}}/resources/help.svg?cache_bust={{.CacheBust}}"
                                class="header-button-image" />
                        </button>
                        <button id="kick-button" onclick="showKickDialog()" class="dialog-button header-button"
                            alt="{{.Translation.Get "votekick-a-player"}}"
                            title="{{.Translation.Get "votekick-a-player"}}">
                            <img src="{{.RootPath}}/resources/kick.png?cache_bust={{.CacheBust}}"
                                class="header-button-image" />
                        </button>
                        <button id="lobby-settings-button" style="display: none;" onclick="showLobbySettingsDialog()"
                            class="dialog-button header-button"
                            alt="{{.Translation.Get "change-lobby-settings-tooltip"}}"
                            title="{{.Translation.Get "change-lobby-settings-tooltip"}}">
                            <img src="{{.RootPath}}/resources/settings.svg?cache_bust={{.CacheBust}}"
                                class="header-button-image" />
                        </button>
                    </div>
                </div>

                <div id="time-left">
                    <img src=" {{.RootPath}}/resources/clock.svg?cache_bust={{.CacheBust}}"
                        class="header-button-image" />
                    <div id="time-left-value">âˆž</div>
                </div>
            </div>

            <div id="player-container"></div>

            <div id="drawing-board-wrapper">
                <div id="drawing-board-inner-wrapper">
                    <canvas id="drawing-board"></canvas>

                    <!-- The so called "center dialogs" are divs that float above the canvas.
                    They are are always both horizontally and vertically. They can bever be
                    as big as the canvas and are usually closable, as long as it makes sense.
                    The can be seen as a new "window" and prevent touch and pointer events
                    from reaching the canvas. Technically there could be more than one dialog
                    visible at a time, but they'll be layered and there's no rule as to how. -->
                    <div id="center-dialogs">
                        <div id="word-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "choose-a-word"}}</span>
                            <div class="center-dialog-content">
                                <div id="word-button-container">
                                </div>
                            </div>
                        </div>

                        <div id="start-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "start-the-game"}}</span>
                            <div class="center-dialog-content">
                                <div style="display: flex; flex-direction: column;">
                                    {{.Translation.Get "change-your-name"}}:
                                    <div style="display: flex; flex-direction: row;">
                                        <input class="namechange-field" type="text"
                                            id="namechange-field-start-dialog"></input>
                                        <button class="dialog-button namechange-apply-button"
                                            onclick="changeName(document.getElementById('namechange-field-start-dialog').value)">{{.Translation.Get "apply"}}</button>
                                    </div>
                                </div>
                            </div>
                            <div class="button-center-wrapper">
                                <button class="dialog-button"
                                    onclick="startGame()">{{.Translation.Get "start"}}</button>
                            </div>
                        </div>

                        <div id="unstarted-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "game-not-started-title"}}</span>
                            <div class="center-dialog-content">
                                <div style="display: flex; flex-direction: column;">
                                    <p>{{.Translation.Get "waiting-for-host-to-start"}}</p>
                                    {{.Translation.Get "change-your-name"}}:
                                    <div style="display: flex; flex-direction: row;">
                                        <input class="namechange-field" type="text"
                                            id="namechange-field-unstarted-dialog"></input>
                                        <button class="dialog-button namechange-apply-button"
                                            onclick="changeName(document.getElementById('namechange-field-unstarted-dialog').value)">{{.Translation.Get "apply"}}</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="waitchoose-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "waiting-for-word-selection"}}</span>
                            <div class="center-dialog-content">
                                <span id="waitchoose-drawer"></span>&nbsp;{{.Translation.Get "is-choosing-word"}}
                            </div>
                        </div>

                        <div id="namechange-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "change-your-name"}}</span>
                            <div class="center-dialog-content">
                                <form id="username-form"
                                    onsubmit="changeName(document.getElementById('namechange-field').value);hideNameChangeDialog();return false">
                                    <input class="namechange-field" type="text" id="namechange-field"></input>
                                </form>
                            </div>
                            <div class="button-center-wrapper">
                                <button class="dialog-button" type="submit"
                                    form="username-form">{{.Translation.Get "save"}}</button>
                                <button class="dialog-button" type="button"
                                    onclick="hideNameChangeDialog()">{{.Translation.Get "close"}}</button>
                            </div>
                        </div>

                        <div id="lobbysettings-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "change-lobby-settings-title"}}</span>
                            <div class="center-dialog-content">
                                <div class="input-container">
                                    <b>{{.Translation.Get "drawing-time-setting"}}</b>
                                    <input id="lobby-settings-drawing-time" class="input-item" type="number"
                                        name="drawing_time" min="{{.MinDrawingTime}}" max="{{.MaxDrawingTime}}"
                                        value="{{.DrawingTime}}" />
                                    <b>{{.Translation.Get "rounds-setting"}}</b>
                                    <input id="lobby-settings-max-rounds" class="input-item" type="number" name="rounds"
                                        min="{{.MinRounds}}" max="{{.MaxRounds}}" value="{{.Rounds}}" />
                                    <b>{{.Translation.Get "word-select-count-setting"}}</b>
                                    <input id="lobby-settings-word-select-count" class="input-item" type="number" name="word_select_count"
                                           min="{{.MinWordSelectCount}}" max="{{.MaxWordSelectCount}}" value="{{.WordSelectCount}}" />
                                    <b>{{.Translation.Get "timer-start-setting"}}</b>
                                    <input id="lobby-settings-timer-start" class="input-item" type="checkbox" name="timer_start" {{if eq
                                           .TimerStart true}}checked{{end}} />
                                    <b>{{.Translation.Get "max-players-setting"}}</b>
                                    <input id="lobby-settings-max-players" type="number" name="max_players"
                                        min="{{.MinMaxPlayers}}" max="{{.MaxMaxPlayers}}" value="{{.MaxPlayers}}" />
                                    <b>{{.Translation.Get "public-lobby-setting"}}</b>
                                    <input id="lobby-settings-public" type="checkbox" name="public" {{if eq
                                            .Public true}}checked{{end}} />
                                    <b>{{.Translation.Get "custom-words-per-turn-setting"}}</b>
                                    <input id="lobby-settings-custom-words-per-turn" class="input-item" type="number"
                                        name="custom_words_per_turn" min="{{.MinCustomWordsPerTurn}}"
                                        max="{{.MaxCustomWordsPerTurn}}" value="{{.CustomWordsPerTurn}}" />
                                    <b>{{.Translation.Get "players-per-ip-limit-setting"}}</b>
                                    <input id="lobby-settings-clients-per-ip-limit" type="number"
                                        name="clients_per_ip_limit" min="{{.MinClientsPerIPLimit}}"
                                        max="{{.MaxClientsPerIPLimit}}" value="{{.ClientsPerIPLimit}}" />
                                </div>
                            </div>
                            <div class="button-center-wrapper">
                                <button class="dialog-button" onclick="saveLobbySettings()">
                                    {{.Translation.Get "save-settings"}}
                                </button>
                                <button class="dialog-button"
                                    onclick="hideLobbySettingsDialog()">{{.Translation.Get "close"}}</button>
                            </div>
                        </div>

                        <div id="game-over-dialog" class="center-dialog">
                            <span id="game-over-dialog-title" class="dialog-title">Game over!</span>
                            <div class="center-dialog-content">
                                <div id="game-over-scoreboard"></div>
                            </div>
                            <div class="button-center-wrapper">
                                <button id="restart-button" class="dialog-button" onclick="startGame()">Restart</button>
                            </div>
                        </div>

                        <div id="kick-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "votekick-a-player"}}</span>
                            <div class="center-dialog-content">
                                <div id="kick-dialog-players"></div>
                            </div>
                            <div class="button-center-wrapper">
                                <button onclick="hideKickDialog()"
                                    class="dialog-button">{{.Translation.Get "close"}}</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="toolbox">
                <input id="color-picker" class="toolbox-group" type="color" onchange="setColorFromColorPicker()"
                    value="#000000" alt="{{.Translation.Get "change-active-color"}}"
                    title="{{.Translation.Get "change-active-color"}}">
                <div class="color-button-container toolbox-group" alt="{{.Translation.Get "change-active-color"}}"
                    title="{{.Translation.Get "change-active-color"}}">
                    <!-- These buttons use !important for their color in order
                to prevent hover and active colors to appear. -->
                    <div class="color-button-row">
                        <button class="color-button" style="background-color: #ffffff !Important"
                            onmousedown="setColor('#ffffff')" onclick="setColor('#ffffff')"></button>
                        <button class="color-button" style="background-color: #c1c1c1 !Important"
                            onmousedown="setColor('#c1c1c1')" onclick="setColor('#c1c1c1')"></button>
                        <button class="color-button" style="background-color: #ef130b !Important"
                            onmousedown="setColor('#ef130b')" onclick="setColor('#ef130b')"></button>
                        <button class="color-button" style="background-color: #ff7100 !Important"
                            onmousedown="setColor('#ff7100')" onclick="setColor('#ff7100')"></button>
                        <button class="color-button" style="background-color: #ffe400 !Important"
                            onmousedown="setColor('#ffe400')" onclick="setColor('#ffe400')"></button>
                        <button class="color-button" style="background-color: #00cc00 !Important"
                            onmousedown="setColor('#00cc00')" onclick="setColor('#00cc00')"></button>
                        <button class="color-button" style="background-color: #00b2ff !Important"
                            onmousedown="setColor('#00b2ff')" onclick="setColor('#00b2ff')"></button>
                        <button class="color-button" style="background-color: #231fd3 !Important"
                            onmousedown="setColor('#231fd3')" onclick="setColor('#231fd3')"></button>
                        <button class="color-button" style="background-color: #a300ba !Important"
                            onmousedown="setColor('#a300ba')" onclick="setColor('#a300ba')"></button>
                        <button class="color-button" style="background-color: #d37caa !Important"
                            onmousedown="setColor('#d37caa')" onclick="setColor('#d37caa')"></button>
                        <button class="color-button" style="background-color: #a0522d !Important"
                            onmousedown="setColor('#a0522d')" onclick="setColor('#a0522d')"></button>
                        <button class="color-button" style="background-color: #592f2a !Important"
                            onmousedown="setColor('#592f2a')" onclick="setColor('#592f2a')"></button>
                        <button class="color-button" style="background-color: #ecbcb4 !Important"
                            onmousedown="setColor('#ecbcb4')" onclick="setColor('#ecbcb4')"></button>
                    </div>
                    <div class="color-button-row">
                        <button class="color-button" style="background-color: #000000 !Important"
                            onmousedown="setColor('#000000')" onclick="setColor('#000000')"></button>
                        <button class="color-button" style="background-color: #4c4c4c !Important"
                            onmousedown="setColor('#4c4c4c')" onclick="setColor('#4c4c4c')"></button>
                        <button class="color-button" style="background-color: #740b07 !Important"
                            onmousedown="setColor('#740b07')" onclick="setColor('#740b07')"></button>
                        <button class="color-button" style="background-color: #c23800 !Important"
                            onmousedown="setColor('#c23800')" onclick="setColor('#c23800')"></button>
                        <button class="color-button" style="background-color: #e8a200 !Important"
                            onmousedown="setColor('#e8a200')" onclick="setColor('#e8a200')"></button>
                        <button class="color-button" style="background-color: #005510 !Important"
                            onmousedown="setColor('#005510')" onclick="setColor('#005510')"></button>
                        <button class="color-button" style="background-color: #00569e !Important"
                            onmousedown="setColor('#00569e')" onclick="setColor('#00569e')"></button>
                        <button class="color-button" style="background-color: #0e0865 !Important"
                            onmousedown="setColor('#0e0865')" onclick="setColor('#0e0865')"></button>
                        <button class="color-button" style="background-color: #550069 !Important"
                            onmousedown="setColor('#550069')" onclick="setColor('#550069')"></button>
                        <button class="color-button" style="background-color: #a75574 !Important"
                            onmousedown="setColor('#a75574')" onclick="setColor('#a75574')"></button>
                        <button class="color-button" style="background-color: #63300d !Important"
                            onmousedown="setColor('#63300d')" onclick="setColor('#63300d')"></button>
                        <button class="color-button" style="background-color: #492f31 !Important"
                            onmousedown="setColor('#492f31')" onclick="setColor('#492f31')"></button>
                        <button class="color-button" style="background-color: #d1a3a4 !Important"
                            onmousedown="setColor('#d1a3a4')" onclick="setColor('#d1a3a4')"></button>
                    </div>
                </div>
                <!--The following buttons als override onmousedown and onmouseup to make
                selection more foolproof. This was done, because many people seem to
                only make half a click (either up or down) in the right location.-->
                <div class="pencil-sizes-container toolbox-group">
                    <label for="tool-type-pencil">
                        <input id="tool-type-pencil" class="custom-check-or-radio line-width-button"
                            onchange="chooseTool(pen)" type="radio" name="tool-type" checked>
                        <div onmousedown="document.getElementById('tool-type-pencil').click()"
                            onmouseup="document.getElementById('tool-type-pencil').click()"
                            class="line-width-button-content">
                            <img title="{{.Translation.Get "use-pencil"}}" alt="{{.Translation.Get "use-pencil"}}"
                                src="{{.RootPath}}/resources/pencil.svg?cache_bust={{.CacheBust}}"
                                style="transform: scaleX(-1)" width="40px" height="40px" />
                        </div>
                    </label>
                    <label for="tool-type-fill">
                        <input id="tool-type-fill" class="custom-check-or-radio line-width-button"
                            onchange="chooseTool(fillBucket)" type="radio" name="tool-type">
                        <div onmousedown="document.getElementById('tool-type-fill').click()"
                            onmouseup="document.getElementById('tool-type-fill').click()"
                            class="line-width-button-content">
                            <img alt="{{.Translation.Get "use-fill-bucket"}}"
                                title="{{.Translation.Get "use-fill-bucket"}}"
                                src="{{.RootPath}}/resources/fill.svg?cache_bust={{.CacheBust}}" width="40px"
                                height="40px" />
                        </div>
                    </label>
                    <label for="tool-type-rubber">
                        <input id="tool-type-rubber" class="custom-check-or-radio line-width-button"
                            onchange="chooseTool(rubber)" type="radio" name="tool-type">
                        <div onmousedown="document.getElementById('tool-type-rubber').click()"
                            onmouseup="document.getElementById('tool-type-rubber').click()"
                            class="line-width-button-content">
                            <img alt="{{.Translation.Get "use-eraser"}}" title="{{.Translation.Get "use-eraser"}}"
                                src="{{.RootPath}}/resources/rubber.svg?cache_bust={{.CacheBust}}" width="40px"
                                height="40px" />
                        </div>
                    </label>
                </div>
                <div class="pencil-sizes-container toolbox-group">
                    <label for="size-8-button">
                        <input id="size-8-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(8)" type="radio" name="line-width" checked>
                        <div onmousedown="document.getElementById('size-8-button').click()"
                            onmouseup="document.getElementById('size-8-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "8"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "8"}}">
                            <div class="dot" style="width: 8px; height: 8px"></div>
                        </div>
                    </label>
                    <label for="size-16-button">
                        <input id="size-16-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(16)" type="radio" name="line-width">
                        <div onmousedown="document.getElementById('size-16-button').click()"
                            onmouseup="document.getElementById('size-16-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "16"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "16"}}">
                            <div class="dot" style="width: 16px; height: 16px"></div>
                        </div>
                    </label>
                    <label for="size-24-button">
                        <input id="size-24-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(24)" type="radio" name="line-width">
                        <div onmousedown="document.getElementById('size-24-button').click()"
                            onmouseup="document.getElementById('size-24-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "24"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "24"}}">
                            <div class="dot" style="width: 24px; height: 24px"></div>
                        </div>
                    </label>
                    <label for="size-32-button">
                        <input id="size-32-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(32)" type="radio" name="line-width">
                        <div onmousedown="document.getElementById('size-32-button').click()"
                            onmouseup="document.getElementById('size-32-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "32"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "32"}}">
                            <div class="dot" style="width: 32px; height: 32px"></div>
                        </div>
                    </label>
                </div>
                <!--We won't make these two buttons easier to click, as there's no going back. -->
                <button class="canvas-button toolbox-group" onclick="clearCanvasAndSendEvent()"
                    alt="{{.Translation.Get "clear-canvas"}}" title="{{.Translation.Get "clear-canvas"}}">
                    <img alt="{{.Translation.Get "clear-canvas"}}" title="{{.Translation.Get "clear-canvas"}}"
                        src="{{.RootPath}}/resources/trash.svg?cache_bust={{.CacheBust}}" width="40px" height="40px" />
                </button>
                <!--We won't make this button easier to click, as there's no going back. -->
                <button class="canvas-button toolbox-group" onclick="undoAndSendEvent()"
                    alt="{{.Translation.Get "undo"}}" title="{{.Translation.Get "undo"}}">
                    <img alt="{{.Translation.Get "undo"}}" title="{{.Translation.Get "undo"}}"
                        src="{{.RootPath}}/resources/undo.svg?cache_bust={{.CacheBust}}" width="40px" height="40px" />
                </button>
            </div>

            <div id="chat">
                <div id="message-container"></div>
                <form class="message-input-form" onsubmit="return sendMessage()">
                    <input id="message-input" type="text" autocomplete="off"
                        placeholder="{{.Translation.Get "message-input-placeholder"}}" />
                    <span id="message-char-count"></span>
                </form>
            </div>
        </div>

        {{template "footer" .}}
    </div>

    <script type="text/javascript" src="{{.RootPath}}/resources/floodfill.js?cache_bust={{.CacheBust}}"></script>
    <script type="text/javascript">
        String.prototype.format = function () {
            return [...arguments].reduce((p, c) => p.replace(/%s/, c), this);
        };

        let socketIsConnecting = false;
        let hasSocketEverConnected = false;
        let socket;
        function connectToWebsocket() {
            if (socketIsConnecting === true) {
                return;
            }

            socketIsConnecting = true;

            if (location.protocol === "https:") {
                console.log("Attempting secure socket connection ...");
                socket = new WebSocket("wss://" + location.hostname + ":" + location.port + "{{.RootPath}}/v1/lobby/{{.LobbyID}}/ws");
            } else {
                console.log("Attempting socket connection ...");
                socket = new WebSocket("ws://" + location.hostname + ":" + location.port + "{{.RootPath}}/v1/lobby/{{.LobbyID}}/ws");
            }

            socket.onerror = error => {
                //Is not connected and we haven't yet said that we are done trying to
                //connect, this means that we could never even establish a connection.
                if (socket.readyState != 1 && !hasSocketEverConnected) {
                    socketIsConnecting = false;
                    showTextDialog("connection-error-dialog",
                        '{{.Translation.Get "error-connecting"}}',
                        '{{.Translation.Get "error-connecting-text"}}');
                    console.log("Error establishing connection: ", error);
                } else {
                    console.log("Socket error: ", error)
                }
            };

            socket.onopen = () => {
                closeDialog(reconnectDialogId);

                hasSocketEverConnected = true;
                socketIsConnecting = false;

                socket.onclose = event => {
                    //We want to avoid handling the error multiple times and showing the incorrect dialogs.
                    socket.onerror = null;

                    console.log("Socket Closed Connection: ", event);
                    console.log("Attempting to reestablish socket connection.");
                    showReconnectDialogIfNotShown();
                    connectToWebsocket();
                };

                registerMessageHandler(socket);

                console.log("Successfully Connected");
            };
        }

        const reconnectDialogId = "reconnect-dialog";
        function showReconnectDialogIfNotShown() {
            const previousReconnectDialog = document.getElementById(reconnectDialogId);

            //Since the content is constant, there's no need to ever show two.
            if (previousReconnectDialog === undefined || previousReconnectDialog === null) {
                showTextDialog(reconnectDialogId, '{{.Translation.Get "connection-lost"}}',
                    '{{.Translation.Get "connection-lost-text"}}');
            }
        }

        connectToWebsocket();

        //In order to avoid automatically canceling the socket connection, we keep
        //sending dummy events every 5 seconds. This was a problem on Heroku. If
        //a player took a very long time to choose a word, the connection of all
        //players could be killed and even cause the lobby being closed. Since
        //that's very frustrating, we want to avoid that.
        window.setInterval(() => {
            socket.send(JSON.stringify({ type: "keep-alive" }));
        }, 5000);

        //Makes sure that the server notices that the player disconnects.
        //Otherwise a refresh (on chromium based browsers) can lead to the server
        //thinking that there's already an open tab with this lobby.
        window.onbeforeunload = () => {
            //Avoid unintentionally reestablishing connection.
            socket.onclose = null;
            socket.close();
        };

        const messageInput = document.getElementById("message-input");
        const messageCharCount = document.getElementById("message-char-count");
        const playerContainer = document.getElementById("player-container");
        const wordContainer = document.getElementById("word-container");
        const chat = document.getElementById("chat");
        const messageContainer = document.getElementById("message-container");
        const roundSpan = document.getElementById("rounds");
        const maxRoundSpan = document.getElementById("max-rounds");
        const timeLeftValue = document.getElementById("time-left-value");
        const drawingBoard = document.getElementById("drawing-board");

        const colorPicker = document.getElementById("color-picker");

        const centerDialogs = document.getElementById("center-dialogs");

        const unstartedDialog = document.getElementById("unstarted-dialog");
        const waitChooseDialog = document.getElementById("waitchoose-dialog");
        const waitChooseDrawerSpan = document.getElementById("waitchoose-drawer");
        const namechangeDialog = document.getElementById("namechange-dialog");
        const namechangeFieldUnstartedDialog = document.getElementById("namechange-field-unstarted-dialog");
        const namechangeFieldStartDialog = document.getElementById("namechange-field-start-dialog");
        const namechangeField = document.getElementById("namechange-field");

        const lobbySettingsButton = document.getElementById("lobby-settings-button");
        const kickButton = document.getElementById("kick-button");
        const lobbySettingsDialog = document.getElementById("lobbysettings-dialog");
        const lobbySettingsTimerStart = document.getElementById("lobby-settings-timer-start");

        const startDialog = document.getElementById("start-dialog");
        const gameOverDialog = document.getElementById("game-over-dialog");
        const gameOverDialogTitle = document.getElementById("game-over-dialog-title");
        const gameOverScoreboard = document.getElementById("game-over-scoreboard");
        const restartButton = document.getElementById("restart-button");
        const wordDialog = document.getElementById("word-dialog");
        const wordButtonContainer = document.getElementById("word-button-container");
        const kickDialog = document.getElementById("kick-dialog");
        const kickDialogPlayers = document.getElementById("kick-dialog-players");

        const soundToggleLabel = document.getElementById("sound-toggle-label");
        let sound = localStorage.getItem("sound") !== "false";
        updateSoundIcon();

        function showTextDialog(id, title, message) {
            const messageNode = document.createElement("span");
            messageNode.innerText = message;
            showDialog(id, title, messageNode);
        }

        function showDialog(id, title, contentNode, buttonBar) {
            const newDialog = document.createElement("div");
            newDialog.classList.add("center-dialog");
            if (id !== null && id !== "") {
                newDialog.id = id;
            }

            const dialogTitle = document.createElement("span");
            dialogTitle.classList.add("dialog-title");
            dialogTitle.innerText = title;
            newDialog.appendChild(dialogTitle);

            const dialogContent = document.createElement("div");
            dialogContent.classList.add("center-dialog-content");
            dialogContent.appendChild(contentNode);
            newDialog.appendChild(dialogContent);

            if (buttonBar !== null && buttonBar !== undefined) {
                newDialog.appendChild(buttonBar);
            }

            newDialog.style.visibility = "visible";
            centerDialogs.appendChild(newDialog);
        }

        function closeDialog(id) {
            const dialog = document.getElementById(id);
            if (dialog !== undefined && dialog !== null) {
                const parent = dialog.parentElement;
                if (parent !== undefined && parent !== null) {
                    parent.removeChild(dialog);
                }
            }
        }

        const helpDialogId = "help-dialog";
        function showHelpDialog() {
            closeDialog(helpDialogId);
            const controlsLabel = document.createElement("b");
            controlsLabel.innerText = '{{.Translation.Get "controls"}}';

            const controlsTextOne = document.createElement("p");
            controlsTextOne.innerText = '{{.Translation.Get "switch-tools-intro"}}:';

            const controlsTextTwo = document.createElement("p");
            controlsTextTwo.innerHTML = '{{.Translation.Get "pencil"}}: <kbd>Q</kbd><br/>' +
                '{{.Translation.Get "fill-bucket"}}: <kbd>W</kbd><br/>' +
                '{{.Translation.Get "eraser"}}: <kbd>E</kbd><br/>';

            const controlsTextThree = document.createElement("p");
            controlsTextThree.innerHTML = '{{printf (.Translation.Get "switch-pencil-sizes") "<kbd>1</kbd>" "<kbd>4</kbd>"}}';

            const closeButton = document.createElement("button");
            closeButton.innerText = '{{.Translation.Get "close"}}';
            closeButton.classList.add("dialog-button");
            closeButton.addEventListener("click", event => {
                closeDialog(helpDialogId)
            })

            const buttonBar = document.createElement("div");
            buttonBar.classList.add("button-center-wrapper");
            buttonBar.appendChild(closeButton);

            const dialogContent = document.createElement("div");
            dialogContent.appendChild(controlsLabel)
            dialogContent.appendChild(controlsTextOne);
            dialogContent.appendChild(controlsTextTwo);
            dialogContent.appendChild(controlsTextThree);

            showDialog(helpDialogId, '{{.Translation.Get "help"}}', dialogContent, buttonBar);
        }

        function showKickDialog() {
            if (cachedPlayers && cachedPlayers) {
                kickDialogPlayers.innerHTML = "";

                cachedPlayers.forEach(player => {
                    //Don't wanna allow kicking ourselves.
                    if (player.id !== ownID && player.connected) {
                        const playerKickEntry = document.createElement("button");
                        playerKickEntry.classList.add("kick-player-button");
                        playerKickEntry.onclick = () => onVotekickPlayer(player.id);
                        playerKickEntry.innerText = player.name;
                        kickDialogPlayers.appendChild(playerKickEntry);
                    }
                });

                kickDialog.style.visibility = "visible";
            }
        }

        function hideKickDialog() {
            kickDialog.style.visibility = "hidden";
        }

        function showNameChangeDialog() {
            namechangeDialog.style.visibility = "visible";
            namechangeField.focus();
        }

        function hideNameChangeDialog() {
            namechangeDialog.style.visibility = "hidden";
        }

        function changeName(name) {
            //Avoid unnecessary traffic.
            if (name !== ownName) {
                socket.send(JSON.stringify({
                    type: "name-change",
                    data: name,
                }));
            }
        }

        function setUsernameLocally(name) {
            ownName = name;
            namechangeFieldUnstartedDialog.value = name;
            namechangeFieldStartDialog.value = name;
            namechangeField.value = name;
        }

        function toggleFullscreen() {
            if (document.fullscreen) {
                document.exitFullscreen();
            } else {
                document.body.requestFullscreen();
            }
        }

        function showLobbySettingsDialog() {
            lobbySettingsDialog.style.visibility = "visible";
        }

        function hideLobbySettingsDialog() {
            lobbySettingsDialog.style.visibility = "hidden";
        }

        function saveLobbySettings() {
            fetch("{{.RootPath}}/v1/lobby/{{.LobbyID}}?" + new URLSearchParams({
                drawing_time: document.getElementById("lobby-settings-drawing-time").value,
                rounds: document.getElementById("lobby-settings-max-rounds").value,
                word_select_count: document.getElementById("lobby-settings-word-select-count").value,
                public: document.getElementById("lobby-settings-public").checked,
                max_players: document.getElementById("lobby-settings-max-players").value,
                clients_per_ip_limit: document.getElementById("lobby-settings-clients-per-ip-limit").value,
                custom_words_per_turn: document.getElementById("lobby-settings-custom-words-per-turn").value,
            }), {
                method: 'PATCH',
            })
                .then(result => {
                    if (result.status === 200) {
                        hideLobbySettingsDialog();
                    } else {
                        result
                            .text()
                            .then(bodyText => {
                                alert("Error saving lobby settings: \n\n - " + bodyText.replace(";", "\n - "));
                            });
                    }
                });
        }

        function toggleSound() {
            sound = !sound;
            localStorage.setItem("sound", sound.toString());
            updateSoundIcon();
        }

        function updateSoundIcon() {
            if (sound) {
                soundToggleLabel.src = "{{.RootPath}}/resources/sound.svg?cache_bust={{.CacheBust}}";
            } else {
                soundToggleLabel.src = "{{.RootPath}}/resources/no-sound.svg?cache_bust={{.CacheBust}}";
            }
        }

        //The drawing board has a base size. This base size results in a certain ratio
        //that the actual canvas has to be resized accordingly too. This is needed
        //since not every client has the same screensize.
        const baseWidth = {{.DrawingBoardBaseWidth }};
        const baseHeight = {{.DrawingBoardBaseHeight }};
        const boardRatio = baseWidth / baseHeight;

        // Moving this here to extract the context after resizing
        const context = drawingBoard.getContext("2d");

        function scaleUpFactor() {
            return baseWidth / drawingBoard.clientWidth;
        }

        //scalesUp the value using scaleUpFactor and reduces the precision.
        //This makes sense since we absolutely don't need the precision and
        //we'll reduce network traffic this way.
        function scaelUpAndPrepareFloatForServer(value) {
            //We reduce the precision in multiple steps, since we get a string
            //as an intermediate result. The reason we don't want a string, is
            //that unmarshalling on the backend won't work with strings for float
            //values, unless explicitly specified, which however will cause it
            //not to work without quotes. Example:
            //  123.213476124918724 -> "123.21" -> 123.21
            return parseFloat((scaleUpFactor() * value).toFixed(2));
        }

        function scaleDownFactor() {
            return drawingBoard.clientWidth / baseWidth;
        }

        const pen = 0;
        const rubber = 1;
        const fillBucket = 2;

        let allowDrawing = false;

        //Initially, we require some values to avoid running into nullpointers
        //or undefined errors. The specific values don't really matter.
        let localTool = pen;
        let localLineWidth = 8;
        let localLineWidthUnscaled = 8;

        //Those are not scaled for now, as the whole toolbar would then have to incorrectly size up and down.
        const sizeButton8 = document.getElementById("size-8-button");
        const sizeButton16 = document.getElementById("size-16-button");
        const sizeButton24 = document.getElementById("size-24-button");
        const sizeButton32 = document.getElementById("size-32-button");

        const toolButtonPen = document.getElementById("tool-type-pencil");
        const toolButtonRubber = document.getElementById("tool-type-rubber");
        const toolButtonFill = document.getElementById("tool-type-fill");

        //We use the states present in UI elements, since in case of
        //hitting F5(Refresh), the browser will not reset these states to the
        //initial values defined in the HTML.
        //The necessary cursor update implicitly happens with setLineWidth.
        let localColor = hexStringToRgbColorObject(colorPicker.value);

        if (sizeButton8.checked) {
            setLineWidth(8);
        } else if (sizeButton16.checked) {
            setLineWidth(16);
        } else if (sizeButton24.checked) {
            setLineWidth(24);
        } else if (sizeButton32.checked) {
            setLineWidth(32);
        }

        if (toolButtonPen.checked) {
            chooseTool(pen);
        } else if (toolButtonFill.checked) {
            chooseTool(fillBucket);
        } else if (toolButtonRubber.checked) {
            chooseTool(rubber);
        }

        function setColorFromColorPicker() {
            setColorWithoutUpdatingColorPicker(colorPicker.value);
        }

        function setColor(color) {
            colorPicker.value = color;
            setColorWithoutUpdatingColorPicker(color);
        }

        function setColorWithoutUpdatingColorPicker(color) {
            localColor = hexStringToRgbColorObject(color);

            if (localTool === rubber) {
                //Hack to correct selection. Doesn't automatically trigger chooseTool(pen).
                toolButtonPen.click();
                chooseTool(pen);
                //Cursor update is implicit.
            } else {
                updateCursor();
            }
        }

        function setLineWidth(value) {
            localLineWidthUnscaled = value;
            localLineWidth = value * scaleDownFactor();
            updateCursor();
        }

        function chooseTool(value) {
            if (value === pen || value === rubber || value === fillBucket) {
                localTool = value;
            } else {
                //If this ends up with an invalid value, we use the pencil.
                localTool = pen;
            }
            updateCursor();
        }

        //We accept both #RRGGBB and RRGGBB. Both are treated case insensitive.
        function hexStringToRgbColorObject(hexString) {
            const hexColorsRegex = /#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i;
            const match = hexString.match(hexColorsRegex)
            return { r: parseInt(match[1], 16), g: parseInt(match[2], 16), b: parseInt(match[3], 16) };
        }

        function rgbColorObjectToHexString(color) {
            return "#"
                + numberTo16BitHexadecimal(color.r)
                + numberTo16BitHexadecimal(color.g)
                + numberTo16BitHexadecimal(color.b);
        }

        function numberTo16BitHexadecimal(number) {
            return Number(number).toString(16).padStart(2, "0");
        }

        const rubberColor = { r: 255, g: 255, b: 255 };

        function updateCursor() {
            if (allowDrawing) {
                if (localTool === rubber) {
                    setCircleCursor(rubberColor, localLineWidth);
                } else if (localTool === fillBucket) {
                    const outerColor = getComplementaryCursorColor(localColor);
                    drawingBoard.style.cursor = `url('data:image/svg+xml;utf8,`
                        + encodeURIComponent(
                            `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="32" width="32">`
                            + generateSVGCircle(8, localColor, outerColor)
                            //This has been taken from fill.svg
                            + `
                                <svg viewBox="0 0 64 64" x="8" y="8" height="24" width="24">
                                    <path
                                        d="m 59.575359,58.158246 c 0,1.701889 -1.542545,3.094345 -3.427877,3.094345 H 8.1572059 c -1.8853322,0 -3.4278772,-1.392456 -3.4278772,-3.094345 V 5.5543863 c 0,-1.7018892 1.542545,-3.0943445 3.4278772,-3.0943445 H 56.147482 c 1.885332,0 3.427877,1.3924553 3.427877,3.0943445 z"
                                        id="path8"
                                        style="stroke-width:1.62842;fill:#b3b3b3" />
                                    <path
                                        d="M 56.147482,2.4600418 H 8.1572059 c -1.8853322,0 -3.4278772,1.3152251 -3.4278772,2.9227219 V 14.15093 c 0,1.607497 0,0 0,0 l 26.5660453,2.922722 c 0.685576,0 2.570908,0.584545 2.570908,1.89977 0,0 0,1.899769 0,2.484313 0,1.169089 1.199758,2.192042 2.570908,2.192042 1.371151,0 2.570908,-1.022953 2.570908,-2.192042 0,-1.169089 1.199756,-2.192041 2.570908,-2.192041 1.37115,0 2.570907,1.022952 2.570907,2.192041 v 19.728374 c 0,1.169089 1.199757,2.192042 2.570908,2.192042 1.37115,0 2.570907,-1.022953 2.570907,-2.192042 V 25.841818 c 0,-1.169088 1.199758,-2.192041 2.570908,-2.192041 1.371151,0 2.570908,1.022953 2.570908,2.192041 v 3.653404 c 0,1.169088 1.199756,2.192041 2.570907,2.192041 1.371151,0 2.570908,-1.022953 2.570908,-2.192041 V 5.3827637 c 0,-1.6074968 -1.542545,-2.9227219 -3.427877,-2.9227219 z"
                                        id="path12"
                                        style="stroke-width:1.58262;fill:#C75C5C" />
                                    <path
                                        d="m 60.432329,6.1134441 c 0,13.2983859 -12.683145,24.1124579 -28.279986,24.1124579 -15.596839,0 -28.2799836,-10.814072 -28.2799836,-24.1124579"
                                        id="path18"
                                        style="fill:none;stroke:#4F5D73;stroke-width:2;stroke-linecap:round;stroke-miterlimit:10" />
                                </svg>
                            </svg>`
                        )
                        + `') 4 4, auto`;
                } else {
                    setCircleCursor(localColor, localLineWidth);
                }
            } else {
                drawingBoard.style.cursor = 'not-allowed';
            }
        }

        function getComplementaryCursorColor(innerColor) {
            const hsp = Math.sqrt(
                0.299 * (innerColor.r * innerColor.r) +
                0.587 * (innerColor.g * innerColor.g) +
                0.114 * (innerColor.b * innerColor.b)
            );

            if (hsp > 127.5) {
                return { r: 0, g: 0, b: 0 };
            }

            return { r: 255, g: 255, b: 255 };
        }

        function setCircleCursor(innerColor, size) {
            const outerColor = getComplementaryCursorColor(innerColor);
            const circleSize = size * scaleUpFactor();
            drawingBoard.style.cursor = `url('data:image/svg+xml;utf8,`
                + encodeURIComponent(
                    `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="32" height="32">`
                    + generateSVGCircle(circleSize, innerColor, outerColor) + `</svg>')`
                )
                + ` ` + (circleSize / 2) + ` ` + (circleSize / 2) + `, auto`;
        }

        function generateSVGCircle(circleSize, innerColor, outerColor) {
            const circleRadius = (circleSize / 2);
            const innerColorCSS = "rgb(" + innerColor.r + "," + innerColor.g + "," + innerColor.b + ")";
            const outerColorCSS = "rgb(" + outerColor.r + "," + outerColor.g + "," + outerColor.b + ")";
            return `<circle cx="` + circleRadius + `" cy="` + circleRadius + `" r="` + circleRadius + `" style="fill: ` + innerColorCSS + `; stroke: ` + outerColorCSS + `;"/>`;
        }

        function startGame() {
            socket.send(JSON.stringify({
                type: "start",
            }));
        }

        function clearCanvasAndSendEvent() {
            if (allowDrawing) {
                //Avoid unnecessary traffic back to us and handle the clear directly.
                clear(context);
                socket.send(JSON.stringify({
                    type: "clear-drawing-board"
                }));
            }
        }

        function undoAndSendEvent() {
            if (allowDrawing) {
                socket.send(JSON.stringify({
                    type: "undo"
                }));
            }
        }

        //Used to restore the last message on arrow up.
        let lastMessage = "";

        function sendMessage() {
            lastMessage = messageInput.value;

            //We first check if there's more than 10000 characters and only if
            //there isn't, we check for more than 10000 bytes, as that's
            //potentially slower.
            if (messageInput.value.length > 10000
                || (new TextEncoder().encode(messageInput.value)).length > 10000) {
                appendMessage("system-message", '{{.Translation.Get "system"}}',
                    '{{.Translation.Get "message-too-long"}}');
                //We keep the messageInput content, since it could've been
                //something important and we don't want the user having to
                //rewrite it. Instead they can send it via some other means
                //or shorten it a bit.
            } else {
                socket.send(JSON.stringify({
                    type: "message",
                    data: messageInput.value
                }));
                messageInput.value = "";
            }

            // Necessary in order to keep the page from submitting.
            return false;
        }

        function chooseWord(index) {
            socket.send(JSON.stringify({
                type: "choose-word",
                data: index
            }));
            wordChosen = true;
            allowDrawing = true;
            updateCursor();
            wordDialog.style.visibility = "hidden";

            if(lobbySettingsTimerStart.checked) {
                startRoundTimer();
            }
        }

        function addWordCharCount(wordLength) {
            const wordCharCountContainer = document.createElement("span");

            wordCharCountContainer.id = 'word-char-count-container';
            wordCharCountContainer.innerHTML = wordLength;

            wordContainer.appendChild(wordCharCountContainer);

        }

        function onVotekickPlayer(playerId) {
            socket.send(JSON.stringify({
                type: "kick-vote",
                data: playerId
            }));
            hideKickDialog();
        }

        //This automatically scrolls down the chat on arrivals of new messages
        new MutationObserver(() => messageContainer.scrollTop = messageContainer.scrollHeight)
            .observe(messageContainer, {
                attributes: false,
                childList: true,
                subtree: false
            });

        messageInput.addEventListener("keydown", function (event) {
            if (event.keyCode === 38 /* arrow up */ && messageInput.value.length === 0) {
                messageInput.value = lastMessage;
            }
        });

        messageInput.addEventListener('keyup', function (event) {
            const message = messageInput.value;

            messageCharCount.innerHTML = message.replace(/\s/g, '').length.toString();
        });

        let ownID, ownerID, ownName, drawerID, drawerName;
        let round = 0;
        let rounds = 0;
        let roundEndTime = 0;
        let gameState = "unstarted";
        let drawingTimeSetting = "âˆž";
        let wordSelectCountSetting = "3";

        function registerMessageHandler(targetSocket) {
            targetSocket.onmessage = event => {
                const parsed = JSON.parse(event.data);
                if (parsed.type === "ready") {
                    handleReadyEvent(parsed.data);
                } else if (parsed.type === "word-chosen") {
                    setRoundEndTime(parsed.data.roundEndTime);
                } else if (parsed.type === "game-over") {
                    let ready = parsed.data;
                    showRoundEndMessage(ready.previousWord);
                    handleReadyEvent(ready);
                } else if (parsed.type === "update-players") {
                    applyPlayers(parsed.data);
                } else if (parsed.type === "name-change") {
                    const player = getPlayer(parsed.data.playerId);
                    if (player !== null) {
                        player.name = parsed.data.playerName;
                    }

                    const playernameSpan = document.getElementById("playername-" + parsed.data.playerId);
                    if (playernameSpan !== null) {
                        playernameSpan.innerText = parsed.data.playerName;
                    }
                    if (parsed.data.playerId === ownID) {
                        setUsernameLocally(parsed.data.playerName);
                    }
                    if (parsed.data.playerId === drawerID) {
                        waitChooseDrawerSpan.innerText = parsed.data.playerName;
                    }
                } else if (parsed.type === "correct-guess") {
                    playWav('{{.RootPath}}/resources/plop.wav?cache_bust={{.CacheBust}}');

                    if (parsed.data === ownID) {
                        appendMessage("correct-guess-message", null, '{{.Translation.Get "correct-guess"}}');
                    } else {
                        const player = getPlayer(parsed.data)
                        if (player !== null) {
                            appendMessage("correct-guess-message-other-player", null, '{{.Translation.Get "correct-guess-other-player"}}'.format(player.name));
                        }
                    }
                } else if (parsed.type === "close-guess") {
                    appendMessage("close-guess-message", null, '{{.Translation.Get "close-guess"}}'.format(parsed.data));
                } else if (parsed.type === "update-wordhint") {
                    // this event is (also) sent if the drawer has choosen a word, so we can hide the waitChooseDialog
                    waitChooseDialog.style.visibility = "hidden";
                    applyWordHints(parsed.data.wordHints);
                    setRoundEndTime(parsed.data.roundEndTime);
                    startRoundTimer();
                } else if (parsed.type === "message") {
                    appendMessage(null, parsed.data.author, parsed.data.content);
                } else if (parsed.type === "system-message") {
                    appendMessage("system-message", '{{.Translation.Get "system"}}', parsed.data);
                } else if (parsed.type === "non-guessing-player-message") {
                    appendMessage("non-guessing-player-message", parsed.data.author, parsed.data.content);
                } else if (parsed.type === "line") {
                    drawLine(context, parsed.data.fromX * scaleDownFactor(), parsed.data.fromY * scaleDownFactor(), parsed.data.toX * scaleDownFactor(), parsed.data.toY * scaleDownFactor(), parsed.data.color, parsed.data.lineWidth * scaleDownFactor());
                } else if (parsed.type === "fill") {
                    fillFlood(context, parsed.data.x * scaleDownFactor(), parsed.data.y * scaleDownFactor(), parsed.data.color);
                } else if (parsed.type === "clear-drawing-board") {
                    clear(context);
                } else if (parsed.type === "next-turn") {
                    setRoundEndTime(parsed.data.roundEndTime);

                    //As soon as a turn starts, the round should be ongoing, so we make
                    //sure that all types of dialogs, that indicate the game isn't
                    //ongoing, are not visible anymore.
                    unstartedDialog.style.visibility = "hidden";
                    startDialog.style.visibility = "hidden";
                    restartButton.style.display = "none";
                    gameOverDialog.style.visibility = "hidden";

                    //If a player doesn't choose, the dialog will still be up.
                    wordDialog.style.visibility = "hidden";
                    playWav('{{.RootPath}}/resources/end-turn.wav?cache_bust={{.CacheBust}}');

                    clear(context);

                    round = parsed.data.round;
                    updateRoundsDisplay();
                    applyPlayers(parsed.data.players);

                    //Even though we always hide the dialog in the "your-turn"
                    //event handling, it will be shortly visible if we it here.
                    if (drawerID !== ownID) {
                        //Show additional dialog, that another user (drawer) is choosing a word
                        waitChooseDrawerSpan.innerText = drawerName;
                        if (parsed.data.length <= 1) {
                            waitChooseDialog.style.visibility = "visible";
                        }
                    }

                    //We clear this, since there's no word chosen right now.
                    wordContainer.innerHTML = "";

                    allowDrawing = false;
                    updateCursor();

                    if (gameState === "ongoing") {
                        //The previous turn has ended.
                        showRoundEndMessage(parsed.data.previousWord);
                    } else {
                        //First turn, the game starts
                        gameState = "ongoing";
                    }
                } else if (parsed.type === "your-turn") {
                    playWav('{{.RootPath}}/resources/your-turn.wav?cache_bust={{.CacheBust}}');
                    //This dialog could potentially stay visible from last
                    //turn, in case nobody has chosen a word.
                    waitChooseDialog.style.visibility = "hidden";

                    promptWords(parsed.data);

                } else if (parsed.type === "drawing") {
                    applyDrawData(parsed.data);
                } else if (parsed.type === "kick-vote") {
                    if (parsed.data.playerId === ownID && parsed.data.voteCount >= parsed.data.requiredVoteCount) {
                        alert('{{.Translation.Get "self-kicked"}}');
                        document.location.href = "{{.RootPath}}/";
                    } else {
                        let kickMessage = '{{.Translation.Get "kick-vote"}}'.format(parsed.data.voteCount, parsed.data.requiredVoteCount, parsed.data.playerName);
                        if (parsed.data.voteCount >= parsed.data.requiredVoteCount) {
                            kickMessage += ' {{.Translation.Get "player-kicked"}}';
                        }
                        appendMessage("system-message", '{{.Translation.Get "system"}}', kickMessage);
                    }
                } else if (parsed.type === "owner-change") {
                    ownerID = parsed.data.playerId;
                    updateButtonVisibilities();
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "owner-change"}}'.format(parsed.data.playerName));
                } else if (parsed.type === "drawer-kicked") {
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "drawer-kicked"}}');
                } else if (parsed.type === "lobby-settings-changed") {
                    rounds = parsed.data.rounds;
                    updateRoundsDisplay();
                    updateButtonVisibilities();
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "lobby-settings-changed"}}\n\n'
                        + '{{.Translation.Get "drawing-time-setting"}}: ' + parsed.data.drawingTime + "\n"
                        + '{{.Translation.Get "word-select-count-setting"}}: ' + parsed.data.wordSelectCount + "\n"
                        + '{{.Translation.Get "rounds-setting"}}: ' + parsed.data.rounds + "\n"
                        + '{{.Translation.Get "public-lobby-setting"}}: ' + parsed.data.public + "\n"
                        + '{{.Translation.Get "max-players-setting"}}: ' + parsed.data.maxPlayers + "\n"
                        + '{{.Translation.Get "custom-words-per-turn-setting"}}: ' + parsed.data.customWordsPerTurn + "%\n"
                        + '{{.Translation.Get "players-per-ip-limit-setting"}}: ' + parsed.data.clientsPerIpLimit);
                } else if (parsed.type === "shutdown") {
                    socket.onclose = null;
                    socket.close();
                    showDialog("shutdown-info", "Server shutting down",
                        document.createTextNode("Sorry, but the server is about to shut down. Please come back at a later time."));
                }
            }
        };

        function showRoundEndMessage(previousWord) {
            if (previousWord === "") {
                appendMessage("system-message", null, '{{.Translation.Get "round-over"}}');
            } else {
                appendMessage("system-message", null, '{{.Translation.Get "round-over-no-word"}}'.format(previousWord));
            }
        }

        function getPlayer(playerID) {
            for (let i = 0; i < cachedPlayers.length; i++) {
                let player = cachedPlayers[i];
                if (player.id === playerID) {
                    return player;
                }
            }

            return null;
        }

        //In the initial implementation we used a timestamp to know when
        //the round will end. The problem with that approach was that the
        //clock on client and server was often not in sync. The second
        //approach was to instead send milliseconds left and keep counting
        //them down each 500 milliseconds. The problem with this approach, was
        //that there could potentially be timing mistakes while counting down.
        //What we do instead is use our local date, add the timeLeft to it and
        //repeatdly recaculate the timeLeft using the roundEndTime and the
        //current time. This way we won't have any calculation errors.
        //
        //FIXME The only leftover issue is that ping isn't taken into
        //account, however, that's no biggie for now.
        function setRoundEndTime(timeLeftMs) {
            roundEndTime = Date.now() + timeLeftMs;
        }

        function handleReadyEvent(ready) {
            setRoundEndTime(ready.roundEndTime);
            ownerID = ready.ownerId;
            setUsernameLocally(ready.playerName);
            allowDrawing = ready.allowDrawing;
            ownID = ready.playerId;
            round = ready.round;
            rounds = ready.rounds;
            gameState = ready.gameState;
            drawingTimeSetting = ready.drawingTimeSetting;
            wordSelectCountSetting = ready.wordSelectCountSetting;
            updateRoundsDisplay();
            updateButtonVisibilities();

            if (ready.players && ready.players.length) {
                applyPlayers(ready.players);
            }
            if (ready.currentDrawing && ready.currentDrawing.length) {
                applyDrawData(ready.currentDrawing);
            }
            if (ready.wordHints && ready.wordHints.length) {
                applyWordHints(ready.wordHints);
            }
            updateCursor();

            if (ready.gameState === "unstarted") {
                if (ownerID === ownID) {
                    startDialog.style.visibility = "visible";
                } else {
                    unstartedDialog.style.visibility = "visible";
                }
            } else if (ready.gameState === "gameOver") {
                gameOverDialog.style.visibility = "visible";
                if (ownerID === ownID) {
                    restartButton.style.display = "block";
                }

                gameOverScoreboard.innerHTML = "";

                //Copying array so we can sort.
                const players = cachedPlayers.slice();
                players.sort((a, b) => {
                    return a.rank - b.rank;
                });

                //These two are required for displaying the "game over / win / tie" message.
                let countOfRankOnePlayers = 0;
                let isSelfRankOne = false;
                for (let i = 0; i < players.length; i++) {
                    const player = players[i];
                    if (!player.connected) {
                        continue;
                    }

                    if (player.rank === 1) {
                        countOfRankOnePlayers++;
                        if (player.id === ownID) {
                            isSelfRankOne = true;
                        }
                    }

                    //Even if we don't want to show a player-entry, we still need to iterate
                    //over all players to handle the dialog titles.
                    if (player.rank <= 5) {
                        const newScoreboardEntry = document.createElement("div");
                        newScoreboardEntry.classList.add("gameover-scoreboard-entry");
                        if (player.id === ownID) {
                            newScoreboardEntry.classList.add("gameover-scoreboard-entry-self");
                        }

                        const scoreboardRankDiv = document.createElement("div");
                        scoreboardRankDiv.classList.add("gameover-scoreboard-rank");
                        scoreboardRankDiv.innerText = player.rank;
                        newScoreboardEntry.appendChild(scoreboardRankDiv);

                        const scoreboardNameDiv = document.createElement("div");
                        scoreboardNameDiv.classList.add("gameover-scoreboard-name");
                        scoreboardNameDiv.innerText = player.name;
                        newScoreboardEntry.appendChild(scoreboardNameDiv);

                        const scoreboardScoreSpan = document.createElement("span");
                        scoreboardScoreSpan.classList.add("gameover-scoreboard-score");
                        scoreboardScoreSpan.innerText = player.score;
                        newScoreboardEntry.appendChild(scoreboardScoreSpan);

                        gameOverScoreboard.appendChild(newScoreboardEntry);
                    }
                }

                if (isSelfRankOne) {
                    if (countOfRankOnePlayers >= 2) {
                        gameOverDialogTitle.innerText = '{{.Translation.Get "game-over-tie"}}';
                    } else {
                        gameOverDialogTitle.innerText = '{{.Translation.Get "game-over-win"}}';
                    }
                } else {
                    gameOverDialogTitle.innerText = '{{.Translation.Get "game-over"}}'.format(player.rank, player.score);
                }
            } else if (ready.gameState === "ongoing") {
                // Lack of wordHints implies that word has been chosen yet.
                if (ready.wordHints === null && drawerID !== ownID) {
                    waitChooseDrawerSpan.innerText = drawerName;

                    waitChooseDialog.style.visibility = "visible";
                }
            }
        }

        function updateButtonVisibilities() {
            if (ownerID === ownID) {
                lobbySettingsButton.style.display = "initial";
            } else {
                lobbySettingsButton.style.display = "none";
            }
        }

        function promptWords(words) {
            wordButtonContainer.innerHTML = '';
            if (words.length <= 1) {
                chooseWord(0);
            } else {
                words.forEach((word, index) => {
                    const button = document.createElement('button');

                    button.innerText = word;
                    button.className = 'dialog-button';
                    button.id = 'word-button-' + index;
                    button.onclick = () => chooseWord(index);

                    wordButtonContainer.appendChild(button);
                });

                wordDialog.style.visibility = "visible";
            }
        }

        function playWav(file) {
            if (sound) {
                const audio = new Audio(file);
                audio.type = 'audio/wav';
                audio.play();
            }
        }

        function startRoundTimer() {
            window.setInterval(() => {
                if (gameState === "ongoing") {
                    const msLeft = roundEndTime - Date.now();
                    const secondsLeft = Math.max(0, Math.floor(msLeft / 1000));
                    timeLeftValue.innerText = "" + secondsLeft
                } else {
                    timeLeftValue.innerText = "" + drawingTimeSetting;
                }
            }, 500);
        }

        if(!lobbySettingsTimerStart.checked) {
            startRoundTimer();
        }
        // window.setInterval(() => {
        //     if (gameState === "ongoing") {
        //         const msLeft = roundEndTime - Date.now();
        //         const secondsLeft = Math.max(0, Math.floor(msLeft / 1000));
        //         timeLeftValue.innerText = "" + secondsLeft
        //     } else {
        //         timeLeftValue.innerText = "" + drawingTimeSetting;
        //     }
        // }, 500);

        //appendMessage adds a new message to the message container. If the
        //message amount is too high, we cut off a part of the messages to
        //prevent lagging and useless memory usage.
        function appendMessage(styleClass, author, message) {
            if (messageContainer.childElementCount >= 100) {
                messageContainer.removeChild(messageContainer.firstChild);
            }

            const newMessageDiv = document.createElement("div");
            newMessageDiv.classList.add("message");
            if (styleClass !== null && styleClass !== "") {
                newMessageDiv.classList.add(styleClass);
            }

            if (author !== null && author !== "") {
                const authorNameSpan = document.createElement("span");
                authorNameSpan.classList.add("chat-name");
                authorNameSpan.innerText = author;
                newMessageDiv.appendChild(authorNameSpan);
            }

            const messageSpan = document.createElement("span");
            messageSpan.classList.add("message-content");
            messageSpan.innerText = message;
            newMessageDiv.appendChild(messageSpan);

            messageContainer.appendChild(newMessageDiv);
        }

        let cachedPlayers;

        //applyPlayers takes the players passed, assigns them to cachedPlayers,
        //refreshes the scoreboard and updates the drawerID and drawerName variables.
        function applyPlayers(players) {
            playerContainer.innerHTML = "";
            cachedPlayers = players;
            players.forEach(player => {
                //We don't wanna show the disconnected players.
                if (!player.connected) {
                    return;
                }

                const playerDiv = document.createElement("div");

                playerDiv.classList.add("player");
                if (player.state === "standby") {
                    playerDiv.classList.add("player-done");
                }

                const rankSpan = document.createElement("span");
                rankSpan.classList.add("rank");
                rankSpan.innerText = player.rank;
                playerDiv.appendChild(rankSpan)

                const playernameSpan = document.createElement("span");
                playernameSpan.classList.add("playername");
                playernameSpan.innerText = player.name;
                playernameSpan.id = "playername-" + player.id;
                if (player.id === ownID) {
                    playernameSpan.classList.add("playername-self");
                }
                playerDiv.appendChild(playernameSpan);

                const scoreAndStatusDiv = document.createElement("div");
                scoreAndStatusDiv.classList.add("score-and-status");
                playerDiv.appendChild(scoreAndStatusDiv);

                const playerscoreDiv = document.createElement("div");
                playerscoreDiv.classList.add("playerscore-group");
                scoreAndStatusDiv.appendChild(playerscoreDiv);

                const playerscoreSpan = document.createElement("span");
                playerscoreSpan.classList.add("playerscore");
                playerscoreSpan.innerText = player.score;
                playerscoreDiv.appendChild(playerscoreSpan);

                const lastPlayerscoreSpan = document.createElement("span");
                lastPlayerscoreSpan.classList.add("last-turn-score");
                lastPlayerscoreSpan.innerText = '{{.Translation.Get "last-turn"}}'.format(player.lastScore);
                playerscoreDiv.appendChild(lastPlayerscoreSpan);


                if (player.state === "drawing") {
                    drawerID = player.id;
                    drawerName = player.name;

                    const playerStateImage = createPlayerStateImageNode("{{.RootPath}}/resources/pencil.svg?cache_bust={{.CacheBust}}");
                    playerStateImage.style.transform = "scaleX(-1)";
                    scoreAndStatusDiv.appendChild(playerStateImage);
                } else if (player.state === "standby") {
                    const playerStateImage = createPlayerStateImageNode("{{.RootPath}}/resources/checkmark.svg?cache_bust={{.CacheBust}}");
                    scoreAndStatusDiv.appendChild(playerStateImage);
                }

                playerContainer.appendChild(playerDiv);
            });
        }

        function createPlayerStateImageNode(path) {
            const playerStateImage = document.createElement("img");
            playerStateImage.style.width = "1rem";
            playerStateImage.style.height = "1rem";
            playerStateImage.src = path;
            return playerStateImage;
        }
        function updateRoundsDisplay() {
            roundSpan.innerText = round;
            maxRoundSpan.innerText = rounds;
        }

        function applyWordHints(wordHints) {
            wordContainer.innerHTML = "";

            wordHints.forEach(hint => {
                const hintSpan = document.createElement("span");
                hintSpan.classList.add("guess-letter");
                if (hint.character === 0) {
                    hintSpan.classList.add("guess-letter-underline");
                    hintSpan.innerHTML = "&nbsp;";
                } else {
                    if (hint.underline) {
                        hintSpan.classList.add("guess-letter-underline");
                    }
                    hintSpan.innerText = String.fromCharCode(hint.character);
                }

                wordContainer.appendChild(hintSpan);
            });

            const wordLength = wordHints.reduce((total, x) => (x !== 32 ? total + 1: total), 0);
            addWordCharCount(wordLength);
        }

        function applyDrawData(drawElements) {
            clear(context);
            const scaleFactor = scaleDownFactor();
            const canvasData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);

            // This implementation directly access the canvas data and does not
            // put it back into the canvas context directly. This saved us not
            // only from calling put, which is relatively cheap, but also from
            // calling getImageData all the time.
            const _drawLine = (x1, y1, x2, y2, color, lineWidth) => {
                // the coordinates must be whole numbers to improve performance.
                // also, decimals as coordinates is not making sense.
                x1 = Math.floor(x1);
                y1 = Math.floor(y1);
                x2 = Math.floor(x2);
                y2 = Math.floor(y2);
                lineWidth = Math.ceil(lineWidth);

                // calculate bounding box; While we don't use this for
                // drawing, we still need to check whether we draw out of
                // bounds or not.
                const left = Math.max(0, Math.min(context.canvas.width, Math.min(x1, x2) - lineWidth));
                const top = Math.max(0, Math.min(context.canvas.height, Math.min(y1, y2) - lineWidth));
                const right = Math.max(0, Math.min(context.canvas.width, Math.max(x1, x2) + lineWidth));
                const bottom = Math.max(0, Math.min(context.canvas.height, Math.max(y1, y2) + lineWidth));
                if (right - left === 0 || bottom - top === 0) {
                    return;
                }

                const circleMap = generateCircleMap(Math.floor(lineWidth / 2));
                const offset = Math.floor(circleMap.length / 2);

                for (let ix = 0; ix < circleMap.length; ix++) {
                    for (let iy = 0; iy < circleMap[ix].length; iy++) {
                        if (circleMap[ix][iy] === 1 || (x1 === x2 && y1 === y2 && circleMap[ix][iy] === 2)) {
                            const newX1 = x1 + ix - offset;
                            const newY1 = y1 + iy - offset;
                            const newX2 = x2 + ix - offset;
                            const newY2 = y2 + iy - offset;
                            drawBresenhamLine(canvasData, newX1, newY1, newX2, newY2, color);
                        }
                    }
                }
            };

            drawElements
                .forEach(drawElement => {
                    const drawData = drawElement.data;
                    if (drawElement.type === "fill") {
                        fillUint8ClampedArray(
                            canvasData.data,
                            drawData.x * scaleFactor, drawData.y * scaleFactor,
                            drawData.color,
                            canvasData.width, canvasData.height);
                    } else if (drawElement.type === "line") {
                        _drawLine(
                            drawData.fromX * scaleFactor, drawData.fromY * scaleFactor,
                            drawData.toX * scaleFactor, drawData.toY * scaleFactor,
                            drawData.color,
                            drawData.lineWidth * scaleFactor);
                    } else {
                        console.log("Unknown draw element type: " + drawData.type);
                    }
                });

            context.putImageData(canvasData, 0, 0);
        }

        let lastX = 0;
        let lastY = 0;

        let touchID = null;

        function onTouchStart(event) {
            //We only allow a single touch
            if (allowDrawing && touchID == null && localTool !== fillBucket) {
                const touch = event.touches[0];
                touchID = touch.identifier;

                // calculate the offset coordinates based on client touch position and drawing board client origin
                const clientRect = drawingBoard.getBoundingClientRect();
                lastX = (touch.clientX - clientRect.left);
                lastY = (touch.clientY - clientRect.top);
            }
        }

        function onTouchMove(event) {
            // Prevent moving, scrolling or zooming the page
            event.preventDefault();

            if (allowDrawing) {
                for (let i = event.changedTouches.length - 1; i >= 0; i--) {
                    if (event.changedTouches[i].identifier === touchID) {
                        const touch = event.changedTouches[i];

                        // calculate the offset coordinates based on client touch position and drawing board client origin
                        const clientRect = drawingBoard.getBoundingClientRect();
                        const offsetX = (touch.clientX - clientRect.left);
                        const offsetY = (touch.clientY - clientRect.top);

                        // drawing functions must check for context boundaries
                        drawLineAndSendEvent(context, lastX, lastY, offsetX, offsetY, localColor, localLineWidth);
                        lastX = offsetX;
                        lastY = offsetY;

                        return;
                    }
                }
            }
        }

        function onTouchEnd(event) {
            for (let i = event.changedTouches.length - 1; i >= 0; i--) {
                if (event.changedTouches[i].identifier === touchID) {
                    touchID = null;
                    return;
                }
            }
        }

        drawingBoard.addEventListener('touchend', onTouchEnd);
        drawingBoard.addEventListener('touchcancel', onTouchEnd);
        drawingBoard.addEventListener('touchstart', onTouchStart);
        drawingBoard.addEventListener('touchmove', onTouchMove);

        function onMouseDown(event) {
            if (allowDrawing && event.buttons === 1 && localTool !== fillBucket) {
                const clientRect = drawingBoard.getBoundingClientRect();
                lastX = event.clientX - clientRect.left;
                lastY = event.clientY - clientRect.top;
            }
        }

        function onMouseMove(event) {
            //event.button === 0 could be wrong, as it can also be the uninitialized state.
            //Therefore we use event.buttons, which works differently.
            if (allowDrawing && event.buttons === 1 && localTool !== fillBucket) {
                // calculate the offset coordinates based on client mouse position and drawing board client origin
                const clientRect = drawingBoard.getBoundingClientRect();
                const offsetX = (event.clientX - clientRect.left);
                const offsetY = (event.clientY - clientRect.top);

                // drawing functions must check for context boundaries
                drawLineAndSendEvent(context, lastX, lastY, offsetX, offsetY, localColor, localLineWidth);
                lastX = offsetX;
                lastY = offsetY;
            }
        }

        function onMouseClick(event) {
            //event.buttons won't work here, since it's always 0. Since we
            //have a click event, we can be sure that we actually had a button
            //clicked and 0 won't be the uninitialized state.
            if (allowDrawing && event.button === 0) {
                if (localTool === fillBucket) {
                    fillAndSendEvent(context, event.offsetX, event.offsetY, localColor);
                } else {
                    drawLineAndSendEvent(context, event.offsetX, event.offsetY,
                        event.offsetX, event.offsetY, localColor, localLineWidth);
                }
            }
        }

        drawingBoard.addEventListener('mousedown', onMouseDown)
        drawingBoard.addEventListener('mousemove', onMouseMove);
        drawingBoard.addEventListener('mouseleave', onMouseMove);
        drawingBoard.addEventListener('click', onMouseClick);

        function onGlobalMouseMove(event) {
            const clientRect = drawingBoard.getBoundingClientRect();
            lastX = Math.min(clientRect.width - 1, Math.max(0, event.clientX - clientRect.left));
            lastY = Math.min(clientRect.height - 1, Math.max(0, event.clientY - clientRect.top));
        }

        //necessary for mousemove to not use the previous exit coordinates.
        //If this is done via mouseleave and mouseenter of the
        //drawingBoard, the lines will end too early on leave and start
        //too late on exit.
        window.addEventListener('mousemove', onGlobalMouseMove);

        function isAnyDialogVisible() {
            for (let i = 0; i < centerDialogs.children.length; i++) {
                if (centerDialogs.children[i].style.visibility === "visible") {
                    return true;
                }
            }

            return false;
        }

        function onKeyDown(event) {
            //Avoid firing actions if the user is in the chat.
            if (document.activeElement instanceof HTMLInputElement) {
                return;
            }

            //If dialogs are open, it doesn't really make sense to be able to
            //change tools. As this is like being in the pause menu of a game.
            if (isAnyDialogVisible()) {
                return;
            }

            //They key choice was made like this, since it's easy to remember
            //and easy to reach. This is how many MOBAs do it and I personally
            //find it better than having to find specific keys on your
            //keyboard. Especially for people that aren't used to typing
            //without looking at their keyboard, this might help.
            if (event.key === "q") {
                toolButtonPen.click();
                chooseTool(pen);
            } else if (event.key === "w") {
                toolButtonFill.click();
                chooseTool(fillBucket);
            } else if (event.key === "e") {
                toolButtonRubber.click();
                chooseTool(rubber);
            } else if (event.key === "1") {
                sizeButton8.click();
                setLineWidth(8);
            } else if (event.key === "2") {
                sizeButton16.click();
                setLineWidth(16);
            } else if (event.key === "3") {
                sizeButton24.click();
                setLineWidth(24);
            } else if (event.key === "4") {
                sizeButton32.click();
                setLineWidth(32);
            }
        }

        //Handling events on the canvas directly isn't possible, since the user
        //must've clicked it at least once in order for that to work.
        window.addEventListener("keydown", onKeyDown);

        function handleCanvasResize() {
            if (drawingBoard.width === drawingBoard.clientWidth && drawingBoard.height === drawingBoard.clientHeight) {
                return false;
            }

            drawingBoard.width = drawingBoard.clientWidth;
            drawingBoard.height = drawingBoard.clientHeight;
            setLineWidth(localLineWidthUnscaled);

            //Ugly workaround to fix https://github.com/scribble-rs/scribble.rs/issues/256
            //Sadly I don't know how to do this with CSS.
            //I've had the same workaround a while ago, but deleted it thinking it
            //wasn't needed anymore, however, without this, the chat container will expand
            //it's own parent, causing overflow-y to not take effect, since the parent has
            //no height constraint.
            //FIXME This isn't optimal for the portrait view. However, the chatview
            //already has a custom max-height in that mode anyway. For the player list
            //it is a worthwhile trade-off for now.
            chat.style.maxHeight = drawingBoard.clientHeight + "px";
            playerContainer.style.maxHeight = drawingBoard.clientHeight + "px";

            return true;
        }

        //Call intially to correct initial state
        handleCanvasResize();

        window.addEventListener("resize", () => {
            if (handleCanvasResize()) {
                //Since the canvas gets cleared, we request the drawing again.
                //Saving it locally would be wasteful and might slow down some
                //clients due to a lot of memory allocation.
                socket.send(JSON.stringify({
                    type: "request-drawing",
                }));
            }
        }, false);


        function clear(context) {
            context.fillStyle = "#FFFFFF";
            context.fillRect(0, 0, drawingBoard.width, drawingBoard.height);
        }

        function fillAndSendEvent(context, x, y, color) {
            if (fillFlood(context, x, y, color)) {
                const fillInstruction = {
                    type: "fill",
                    data: {
                        x: scaelUpAndPrepareFloatForServer(x),
                        y: scaelUpAndPrepareFloatForServer(y),
                        color: color
                    },
                };
                socket.send(JSON.stringify(fillInstruction));
            }
        }

        function drawLineAndSendEvent(context, x1, y1, x2, y2, color, lineWidth) {
            if (localTool === rubber) {
                color = rubberColor;
            }

            drawLine(context, x1, y1, x2, y2, color, lineWidth);

            const drawInstruction = {
                type: "line",
                data: {
                    fromX: scaelUpAndPrepareFloatForServer(x1),
                    fromY: scaelUpAndPrepareFloatForServer(y1),
                    toX: scaelUpAndPrepareFloatForServer(x2),
                    toY: scaelUpAndPrepareFloatForServer(y2),
                    color: color,
                    lineWidth: scaelUpAndPrepareFloatForServer(lineWidth),
                }
            };
            socket.send(JSON.stringify(drawInstruction));
        }

        function drawLine(context, x1, y1, x2, y2, color, lineWidth) {
            // the coordinates must be whole numbers to improve performance.
            // also, decimals as coordinates is not making sense.
            x1 = Math.floor(x1);
            y1 = Math.floor(y1);
            x2 = Math.floor(x2);
            y2 = Math.floor(y2);
            lineWidth = Math.ceil(lineWidth);

            // calculate bounding box
            const left = Math.max(0, Math.min(context.canvas.width, Math.min(x1, x2) - lineWidth));
            const top = Math.max(0, Math.min(context.canvas.height, Math.min(y1, y2) - lineWidth));
            const right = Math.max(0, Math.min(context.canvas.width, Math.max(x1, x2) + lineWidth));
            const bottom = Math.max(0, Math.min(context.canvas.height, Math.max(y1, y2) + lineWidth));

            // off canvas, so don't draw anything
            if (right - left === 0 || bottom - top === 0) {
                return;
            }

            const circleMap = generateCircleMap(Math.floor(lineWidth / 2));
            const offset = Math.floor(circleMap.length / 2);
            const imageData = context.getImageData(left, top, right - left, bottom - top);

            for (let ix = 0; ix < circleMap.length; ix++) {
                for (let iy = 0; iy < circleMap[ix].length; iy++) {
                    if (circleMap[ix][iy] === 1 || (x1 === x2 && y1 === y2 && circleMap[ix][iy] === 2)) {
                        const newX1 = x1 + ix - offset - left;
                        const newY1 = y1 + iy - offset - top;
                        const newX2 = x2 + ix - offset - left;
                        const newY2 = y2 + iy - offset - top;
                        drawBresenhamLine(imageData, newX1, newY1, newX2, newY2, color);
                    }
                }
            }

            context.putImageData(imageData, left, top);
        }

        function drawBresenhamLine(imageData, x1, y1, x2, y2, color) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = (x1 < x2) ? 1 : -1;
            const sy = (y1 < y2) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                //check if pixel is inside the canvas
                if (!(x1 < 0 || x1 >= imageData.width || y1 < 0 || y1 >= imageData.height)) {
                    setPixel(imageData, x1, y1, color);
                }

                if ((x1 === x2) && (y1 === y2)) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
            }
        }

        function generateCircleMap(radius) {
            const diameter = 2 * radius;
            const circleData = new Array(diameter);

            for (let x = 0; x < diameter; x++) {
                circleData[x] = new Array(diameter);
                for (let y = 0; y < diameter; y++) {
                    const distanceToRadius = Math.sqrt(Math.pow(radius - x, 2) + Math.pow(radius - y, 2));
                    if (distanceToRadius > radius) {
                        circleData[x][y] = 0;
                    } else if (distanceToRadius < radius - 2) {
                        circleData[x][y] = 2;
                    } else {
                        circleData[x][y] = 1;
                    }
                }
            }

            return circleData;
        }

        function setPixel(imageData, x, y, color) {
            const offset = (y * imageData.width + x) * 4;
            imageData.data[offset] = color.r;
            imageData.data[offset + 1] = color.g;
            imageData.data[offset + 2] = color.b;
            //We never want transparency, therefore alpha is always 255.
            imageData.data[offset + 3] = 255;
        }
    </script>
</body>

</html>
{{end}}