{{define "lobby-page"}}
<!DOCTYPE html>
<html lang="{{.Locale}}">

<head>
    <title>Scribble.rs - Game</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1, user-scalable=0">
    {{template "non-static-css-decl" .}}
    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/root.css?cache_bust={{.CacheBust}}" />
    <link rel="stylesheet" type="text/css" href="{{.RootPath}}/resources/lobby.css?cache_bust={{.CacheBust}}" />
    {{template "favicon-decl" .}}
    <link rel="prefetch" href="{{.RootPath}}/resources/plop.wav?cache_bust={{.CacheBust}}" />
    <link rel="prefetch" href="{{.RootPath}}/resources/end-turn.wav?cache_bust={{.CacheBust}}" />
    <link rel="prefetch" href="{{.RootPath}}/resources/your-turn.wav?cache_bust={{.CacheBust}}" />
    <link rel="prefetch" href="{{.RootPath}}/resources/pencil.wav?cache_bust={{.CacheBust}}" />
    <link rel="prefetch" href="{{.RootPath}}/resources/checkmark.wav?cache_bust={{.CacheBust}}" />
    <link rel="prefetch" href="{{.RootPath}}/resources/sound.svg?cache_bust={{.CacheBust}}" />
    <link rel="prefetch" href="{{.RootPath}}/resources/no-sound.svg?cache_bust={{.CacheBust}}" />
</head>

<body>
    <div class="content-wrapper">
        <noscript><span class="noscript">{{.Translation.Get "requires-js"}}</span></noscript>

        <div id="lobby">
            <div id="lobby-header">
                <div id="round-container">
                    <img src=" {{.RootPath}}/resources/round.svg?cache_bust={{.CacheBust}}" class="header-button-image"
                        alt="{{.Translation.Get "round"}}" title="{{.Translation.Get "round"}}" />
                    <span id="rounds"></span>
                    <span id="max-rounds"></span>
                </div>

                <div id="lobby-header-center-element">
                    <div>
                        <div>
                            <button id="menu-button" popovertarget="menu" alt="Show menu" title="Show menu">
                                <img src="{{.RootPath}}/resources/menu.svg?cache_bust={{.CacheBust}}"
                                    class="header-button-image" />
                            </button>
                            <div id="menu" popover>
                                <div class="menu-list">
                                    <!-- this button is basically behaving like a checkbox, but in order to
                    have a uniform look with the other buttons in the header, we are not using
                    a checkbox anymore. -->
                                    <button onclick="toggleSound()" class="dialog-button menu-item header-button"
                                        alt="{{.Translation.Get "toggle-soundeffects"}}"
                                        title="{{.Translation.Get "toggle-soundeffects"}}">
                                        <img id="sound-toggle-label" class="header-button-image" />
                                        {{.Translation.Get "toggle-soundeffects"}}
                                    </button>
                                    <button onclick="showNameChangeDialog()"
                                        class="dialog-button menu-item header-button"
                                        alt="{{.Translation.Get "change-your-name"}}"
                                        title="{{.Translation.Get "change-your-name"}}">
                                        <img src="{{.RootPath}}/resources/user.svg?cache_bust={{.CacheBust}}"
                                            class="header-button-image" />
                                        {{.Translation.Get "change-your-name"}}
                                    </button>
                                    <button onclick="toggleFullscreen()" class="dialog-button menu-item header-button"
                                        alt="{{.Translation.Get "toggle-fullscreen"}}"
                                        title="{{.Translation.Get "toggle-fullscreen"}}">
                                        <img src="{{.RootPath}}/resources/fullscreen.svg?cache_bust={{.CacheBust}}"
                                            class="header-button-image" />
                                        {{.Translation.Get "toggle-fullscreen"}}
                                    </button>
                                    <button onclick="toggleSpectate()" class="dialog-button menu-item header-button"
                                        alt="{{.Translation.Get "toggle-spectate"}}"
                                        title="{{.Translation.Get "toggle-spectate"}}">
                                        <img src="{{.RootPath}}/resources/spectate.svg?cache_bust={{.CacheBust}}"
                                            class="header-button-image" />
                                        {{.Translation.Get "toggle-spectate"}}
                                    </button>
                                    <button id="help-button" onclick="showHelpDialog()"
                                        class="dialog-button menu-item header-button"
                                        alt="{{.Translation.Get "show-help"}}" title="{{.Translation.Get "show-help"}}">
                                        <img src="{{.RootPath}}/resources/help.svg?cache_bust={{.CacheBust}}"
                                            class="header-button-image" />
                                        {{.Translation.Get "show-help"}}
                                    </button>
                                    <button id="kick-button" onclick="showKickDialog()"
                                        class="dialog-button menu-item header-button"
                                        alt="{{.Translation.Get "votekick-a-player"}}"
                                        title="{{.Translation.Get "votekick-a-player"}}">
                                        <img src="{{.RootPath}}/resources/kick.png?cache_bust={{.CacheBust}}"
                                            class="header-button-image" />
                                        {{.Translation.Get "votekick-a-player"}}
                                    </button>
                                    <button id="lobby-settings-button" style="display: none;"
                                        onclick="showLobbySettingsDialog()"
                                        class="dialog-button menu-item header-button"
                                        alt="{{.Translation.Get "change-lobby-settings-tooltip"}}"
                                        title="{{.Translation.Get "change-lobby-settings-tooltip"}}">
                                        <img src="{{.RootPath}}/resources/settings.svg?cache_bust={{.CacheBust}}"
                                            class="header-button-image" />
                                        {{.Translation.Get "change-lobby-settings-tooltip"}}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="word-container"></div>
                </div>

                <div id="time-left">
                    <img src=" {{.RootPath}}/resources/clock.svg?cache_bust={{.CacheBust}}"
                        class="header-button-image" />
                    <div id="time-left-value">âˆž</div>
                </div>
            </div>

            <div id="player-container"></div>

            <div id="drawing-board-wrapper">
                <div id="drawing-board-inner-wrapper">
                    <canvas id="drawing-board" width="{{.DrawingBoardBaseWidth}}"
                        height="{{.DrawingBoardBaseHeight}}"></canvas>

                    <!-- The so called "center dialogs" are divs that float above the canvas.
                    They are are always both horizontally and vertically. They can bever be
                    as big as the canvas and are usually closable, as long as it makes sense.
                    The can be seen as a new "window" and prevent touch and pointer events
                    from reaching the canvas. Technically there could be more than one dialog
                    visible at a time, but they'll be layered and there's no rule as to how. -->
                    <div id="center-dialogs">
                        <div id="word-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "choose-a-word"}}</span>
                            <div class="center-dialog-content">
                                <div style="display: flex; flex-direction: column; gap: 0.5rem; align-items: center">
                                    <div>
                                        <span>{{.Translation.Get "word-choice-warning"}}:</span>
                                        <span id="word-preselected" style="font-weight: bold;"></span>
                                    </div>
                                    <div id="word-button-container"> </div>
                                </div>
                            </div>
                        </div>

                        <div id="start-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "start-the-game"}}</span>
                            <div class="center-dialog-content">
                                <div style="display: flex; flex-direction:
                                    column; gap: 0.5rem;">
                                    <div style="display: flex; flex-direction:
                                        row; gap: 0.5rem; align-items: center;">
                                        {{.Translation.Get "change-your-name"}}:
                                        <input class="namechange-field" type="text"
                                            id="namechange-field-start-dialog"></input>
                                        <button class="dialog-button"
                                            onclick="changeName(document.getElementById('namechange-field-start-dialog').value)">{{.Translation.Get "apply"}}</button>
                                    </div>
                                </div>
                            </div>
                            <div class="button-bar">
                                <div class="ready-check-box-wrapper">
                                    <label class="ready-check-box" for="ready-state-start">
                                        Ready
                                        <input type="checkbox" name="ready-state-start" id="ready-state-start"
                                            onchange="toggleReadiness()">
                                        (<span class="ready-count">0</span>/<span class="ready-needed">0</span>)
                                    </label>
                                </div>
                                <button id="force-start-button" class="dialog-button"
                                    onclick="startGame()">{{.Translation.Get "force-start"}}</button>
                            </div>
                        </div>

                        <div id="waitchoose-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "waiting-for-word-selection"}}</span>
                            <div class="center-dialog-content">
                                <span id="waitchoose-drawer"></span>&nbsp;{{.Translation.Get "is-choosing-word"}}
                            </div>
                        </div>

                        <div id="namechange-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "change-your-name"}}</span>
                            <div class="center-dialog-content">
                                <form id="username-form"
                                    onsubmit="changeName(document.getElementById('namechange-field').value);hideNameChangeDialog();return false">
                                    <input class="namechange-field" type="text" id="namechange-field"></input>
                                </form>
                            </div>
                            <div class="button-bar">
                                <button class="dialog-button" type="submit"
                                    form="username-form">{{.Translation.Get "save"}}</button>
                                <button class="dialog-button" type="button"
                                    onclick="hideNameChangeDialog()">{{.Translation.Get "close"}}</button>
                            </div>
                        </div>

                        <div id="lobbysettings-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "change-lobby-settings-title"}}</span>
                            <div class="center-dialog-content">
                                <div class="input-container">
                                    <b>{{.Translation.Get "drawing-time-setting"}}</b>
                                    <input id="lobby-settings-drawing-time" class="input-item" type="number"
                                        name="drawing_time" min="{{.MinDrawingTime}}" max="{{.MaxDrawingTime}}"
                                        value="{{.DrawingTime}}" />
                                    <b>{{.Translation.Get "rounds-setting"}}</b>
                                    <input id="lobby-settings-max-rounds" class="input-item" type="number" name="rounds"
                                        min="{{.MinRounds}}" max="{{.MaxRounds}}" value="{{.Rounds}}" />
                                    <b>{{.Translation.Get "max-players-setting"}}</b>
                                    <input id="lobby-settings-max-players" type="number" name="max_players"
                                        min="{{.MinMaxPlayers}}" max="{{.MaxMaxPlayers}}" value="{{.MaxPlayers}}" />
                                    <b>{{.Translation.Get "public-lobby-setting"}}</b>
                                    <input id="lobby-settings-public" type="checkbox" name="public" {{if eq
                                            .Public true}}checked{{end}} />
                                    <b>{{.Translation.Get "custom-words-per-turn-setting"}}</b>
                                    <input id="lobby-settings-custom-words-per-turn" class="input-item" type="number"
                                        name="custom_words_per_turn" min="{{.MinCustomWordsPerTurn}}"
                                        max="{{.MaxCustomWordsPerTurn}}" value="{{.CustomWordsPerTurn}}" />
                                    <b>{{.Translation.Get "players-per-ip-limit-setting"}}</b>
                                    <input id="lobby-settings-clients-per-ip-limit" type="number"
                                        name="clients_per_ip_limit" min="{{.MinClientsPerIPLimit}}"
                                        max="{{.MaxClientsPerIPLimit}}" value="{{.ClientsPerIPLimit}}" />
                                </div>
                            </div>
                            <div class="button-bar">
                                <button class="dialog-button" onclick="saveLobbySettings()">
                                    {{.Translation.Get "save-settings"}}
                                </button>
                                <button class="dialog-button"
                                    onclick="hideLobbySettingsDialog()">{{.Translation.Get "close"}}</button>
                            </div>
                        </div>

                        <div id="game-over-dialog" class="center-dialog">
                            <span id="game-over-dialog-title" class="dialog-title">Game over!</span>
                            <div class="center-dialog-content">
                                <div id="game-over-scoreboard"></div>
                            </div>
                            <div class="button-bar">
                                <div class="ready-check-box-wrapper">
                                    <label class="ready-check-box" for="ready-state-game-over">
                                        Ready
                                        <input type="checkbox" name="ready-state-game-over" id="ready-state-game-over"
                                            onchange="toggleReadiness()">
                                        (<span class="ready-count">0</span>/<span class="ready-needed">0</span>)
                                    </label>
                                </div>
                                <button id="restart-button" class="dialog-button" onclick="startGame()">{{.Translation.Get
                                    "force-restart"}}</button>
                            </div>
                        </div>

                        <div id="kick-dialog" class="center-dialog">
                            <span class="dialog-title">{{.Translation.Get "votekick-a-player"}}</span>
                            <div class="center-dialog-content">
                                <div id="kick-dialog-players"></div>
                            </div>
                            <div class="button-bar">
                                <button onclick="hideKickDialog()"
                                    class="dialog-button">{{.Translation.Get "close"}}</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="toolbox" style="display: none;">
                <div class="color-button-container toolbox-group" alt="{{.Translation.Get "change-active-color"}}"
                    title="{{.Translation.Get "change-active-color"}}">
                    <!-- These buttons use !important for their color in order
                to prevent hover and active colors to appear. -->
                    <div class="color-button-row">
                        <button class="color-button" style="background-color: #ffffff !Important"
                            onmousedown="setColor(0)" onclick="setColor(0)"></button>
                        <button class="color-button" style="background-color: #c1c1c1 !Important"
                            onmousedown="setColor(1)" onclick="setColor(1)"></button>
                        <button class="color-button" style="background-color: #ef130b !Important"
                            onmousedown="setColor(2)" onclick="setColor(2)"></button>
                        <button class="color-button" style="background-color: #ff7100 !Important"
                            onmousedown="setColor(3)" onclick="setColor(3)"></button>
                        <button class="color-button" style="background-color: #ffe400 !Important"
                            onmousedown="setColor(4)" onclick="setColor(4)"></button>
                        <button class="color-button" style="background-color: #00cc00 !Important"
                            onmousedown="setColor(5)" onclick="setColor(5)"></button>
                        <button class="color-button" style="background-color: #00b2ff !Important"
                            onmousedown="setColor(6)" onclick="setColor(6)"></button>
                        <button class="color-button" style="background-color: #231fd3 !Important"
                            onmousedown="setColor(7)" onclick="setColor(7)"></button>
                        <button class="color-button" style="background-color: #a300ba !Important"
                            onmousedown="setColor(8)" onclick="setColor(8)"></button>
                        <button class="color-button" style="background-color: #d37caa !Important"
                            onmousedown="setColor(9)" onclick="setColor(9)"></button>
                        <button class="color-button" style="background-color: #a0522d !Important"
                            onmousedown="setColor(10)" onclick="setColor(10)"></button>
                        <button class="color-button" style="background-color: #592f2a !Important"
                            onmousedown="setColor(11)" onclick="setColor(11)"></button>
                        <button class="color-button" style="background-color: #ecbcb4 !Important"
                            onmousedown="setColor(12)" onclick="setColor(12)"></button>
                    </div>
                    <div class="color-button-row">
                        <button class="color-button" style="background-color: #000000 !Important"
                            onmousedown="setColor(13)" onclick="setColor(13)"></button>
                        <button class="color-button" style="background-color: #4c4c4c !Important"
                            onmousedown="setColor(14)" onclick="setColor(14)"></button>
                        <button class="color-button" style="background-color: #740b07 !Important"
                            onmousedown="setColor(15)" onclick="setColor(15)"></button>
                        <button class="color-button" style="background-color: #c23800 !Important"
                            onmousedown="setColor(16)" onclick="setColor(16)"></button>
                        <button class="color-button" style="background-color: #e8a200 !Important"
                            onmousedown="setColor(17)" onclick="setColor(17)"></button>
                        <button class="color-button" style="background-color: #005510 !Important"
                            onmousedown="setColor(18)" onclick="setColor(18)"></button>
                        <button class="color-button" style="background-color: #00569e !Important"
                            onmousedown="setColor(19)" onclick="setColor(19)"></button>
                        <button class="color-button" style="background-color: #0e0865 !Important"
                            onmousedown="setColor(20)" onclick="setColor(20)"></button>
                        <button class="color-button" style="background-color: #550069 !Important"
                            onmousedown="setColor(21)" onclick="setColor(21)"></button>
                        <button class="color-button" style="background-color: #a75574 !Important"
                            onmousedown="setColor(22)" onclick="setColor(22)"></button>
                        <button class="color-button" style="background-color: #63300d !Important"
                            onmousedown="setColor(23)" onclick="setColor(23)"></button>
                        <button class="color-button" style="background-color: #492f31 !Important"
                            onmousedown="setColor(24)" onclick="setColor(24)"></button>
                        <button class="color-button" style="background-color: #d1a3a4 !Important"
                            onmousedown="setColor(25)" onclick="setColor(25)"></button>
                    </div>
                </div>
                <!--The following buttons als override onmousedown and onmouseup to make
                selection more foolproof. This was done, because many people seem to
                only make half a click (either up or down) in the right location.-->
                <div class="pencil-sizes-container toolbox-group">
                    <label for="tool-type-pencil">
                        <input id="tool-type-pencil" class="custom-check-or-radio line-width-button"
                            onchange="chooseTool(pen)" type="radio" name="tool-type" checked>
                        <div onmousedown="document.getElementById('tool-type-pencil').click()"
                            onmouseup="document.getElementById('tool-type-pencil').click()"
                            class="line-width-button-content">
                            <img title="{{.Translation.Get "use-pencil"}}" alt="{{.Translation.Get "use-pencil"}}"
                                src="{{.RootPath}}/resources/pencil.svg?cache_bust={{.CacheBust}}"
                                style="transform: scaleX(-1)" />
                        </div>
                    </label>
                    <label for="tool-type-fill">
                        <input id="tool-type-fill" class="custom-check-or-radio line-width-button"
                            onchange="chooseTool(fillBucket)" type="radio" name="tool-type">
                        <div onmousedown="document.getElementById('tool-type-fill').click()"
                            onmouseup="document.getElementById('tool-type-fill').click()"
                            class="line-width-button-content">
                            <img alt="{{.Translation.Get "use-fill-bucket"}}"
                                title="{{.Translation.Get "use-fill-bucket"}}"
                                src="{{.RootPath}}/resources/fill.svg?cache_bust={{.CacheBust}}" />
                        </div>
                    </label>
                    <label for="tool-type-rubber">
                        <input id="tool-type-rubber" class="custom-check-or-radio line-width-button"
                            onchange="chooseTool(rubber)" type="radio" name="tool-type">
                        <div onmousedown="document.getElementById('tool-type-rubber').click()"
                            onmouseup="document.getElementById('tool-type-rubber').click()"
                            class="line-width-button-content">
                            <img alt="{{.Translation.Get "use-eraser"}}" title="{{.Translation.Get "use-eraser"}}"
                                src="{{.RootPath}}/resources/rubber.svg?cache_bust={{.CacheBust}}" />
                        </div>
                    </label>
                </div>
                <div id="size-buttons" class="pencil-sizes-container toolbox-group">
                    <label for="size-8-button">
                        <input id="size-8-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(8)" type="radio" name="line-width" checked>
                        <div onmousedown="document.getElementById('size-8-button').click()"
                            onmouseup="document.getElementById('size-8-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "8"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "8"}}">
                            <div class="dot" style="width: 8px; height: 8px"></div>
                        </div>
                    </label>
                    <label for="size-16-button">
                        <input id="size-16-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(16)" type="radio" name="line-width">
                        <div onmousedown="document.getElementById('size-16-button').click()"
                            onmouseup="document.getElementById('size-16-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "16"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "16"}}">
                            <div class="dot" style="width: 16px; height: 16px"></div>
                        </div>
                    </label>
                    <label for="size-24-button">
                        <input id="size-24-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(24)" type="radio" name="line-width">
                        <div onmousedown="document.getElementById('size-24-button').click()"
                            onmouseup="document.getElementById('size-24-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "24"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "24"}}">
                            <div class="dot" style="width: 24px; height: 24px"></div>
                        </div>
                    </label>
                    <label for="size-32-button">
                        <input id="size-32-button" class="custom-check-or-radio line-width-button"
                            onchange="setLineWidth(32)" type="radio" name="line-width">
                        <div onmousedown="document.getElementById('size-32-button').click()"
                            onmouseup="document.getElementById('size-32-button').click()"
                            class="line-width-button-content"
                            alt="{{printf (.Translation.Get "change-pencil-size-to") "32"}}"
                            title="{{printf (.Translation.Get "change-pencil-size-to") "32"}}">
                            <div class="dot" style="width: 32px; height: 32px"></div>
                        </div>
                    </label>
                </div>
                <!--We won't make these two buttons easier to click, as there's no going back. -->
                <button class="canvas-button toolbox-group" onclick="clearCanvasAndSendEvent()"
                    alt="{{.Translation.Get "clear-canvas"}}" title="{{.Translation.Get "clear-canvas"}}">
                    <img alt="{{.Translation.Get "clear-canvas"}}" title="{{.Translation.Get "clear-canvas"}}"
                        src="{{.RootPath}}/resources/trash.svg?cache_bust={{.CacheBust}}" />
                </button>
                <!--We won't make this button easier to click, as there's no going back. -->
                <button class="canvas-button toolbox-group" onclick="undoAndSendEvent()"
                    alt="{{.Translation.Get "undo"}}" title="{{.Translation.Get "undo"}}">
                    <img alt="{{.Translation.Get "undo"}}" title="{{.Translation.Get "undo"}}"
                        src="{{.RootPath}}/resources/undo.svg?cache_bust={{.CacheBust}}" />
                </button>
            </div>

            <div id="chat">
                <div id="message-container"></div>
                <input id="message-input" type="text" autocomplete="off" onkeypress="sendMessage(event)"
                    placeholder="{{.Translation.Get "message-input-placeholder"}}" />
            </div>
        </div>
    </div>

    <script type="text/javascript" src="{{.RootPath}}/resources/draw.js?cache_bust={{.CacheBust}}"></script>
    <script type="text/javascript">
        String.prototype.format = function () {
            return [...arguments].reduce((p, c) => p.replace(/%s/, c), this);
        };

        let socketIsConnecting = false;
        let hasSocketEverConnected = false;
        let socket;
        function connectToWebsocket() {
            if (socketIsConnecting === true) {
                return;
            }

            socketIsConnecting = true;

            if (location.protocol === "https:") {
                console.log("Attempting secure socket connection ...");
                socket = new WebSocket("wss://" + location.hostname + ":" + location.port + "{{.RootPath}}/v1/lobby/{{.LobbyID}}/ws");
            } else {
                console.log("Attempting socket connection ...");
                socket = new WebSocket("ws://" + location.hostname + ":" + location.port + "{{.RootPath}}/v1/lobby/{{.LobbyID}}/ws");
            }

            socket.onerror = error => {
                //Is not connected and we haven't yet said that we are done trying to
                //connect, this means that we could never even establish a connection.
                if (socket.readyState != 1 && !hasSocketEverConnected) {
                    socketIsConnecting = false;
                    showTextDialog("connection-error-dialog",
                        '{{.Translation.Get "error-connecting"}}',
                        '{{.Translation.Get "error-connecting-text"}}');
                    console.log("Error establishing connection: ", error);
                } else {
                    console.log("Socket error: ", error)
                }
            };

            socket.onopen = () => {
                closeDialog(reconnectDialogId);

                hasSocketEverConnected = true;
                socketIsConnecting = false;

                socket.onclose = event => {
                    //We want to avoid handling the error multiple times and showing the incorrect dialogs.
                    socket.onerror = null;

                    console.log("Socket Closed Connection: ", event);
                    console.log("Attempting to reestablish socket connection.");
                    showReconnectDialogIfNotShown();
                    connectToWebsocket();
                };

                registerMessageHandler(socket);

                console.log("Successfully Connected");
            };
        }

        const reconnectDialogId = "reconnect-dialog";
        function showReconnectDialogIfNotShown() {
            const previousReconnectDialog = document.getElementById(reconnectDialogId);

            //Since the content is constant, there's no need to ever show two.
            if (previousReconnectDialog === undefined || previousReconnectDialog === null) {
                showTextDialog(reconnectDialogId, '{{.Translation.Get "connection-lost"}}',
                    '{{.Translation.Get "connection-lost-text"}}');
            }
        }

        connectToWebsocket();

        //In order to avoid automatically canceling the socket connection, we keep
        //sending dummy events every 5 seconds. This was a problem on Heroku. If
        //a player took a very long time to choose a word, the connection of all
        //players could be killed and even cause the lobby being closed. Since
        //that's very frustrating, we want to avoid that.
        window.setInterval(() => {
            socket.send(JSON.stringify({type: "keep-alive"}));
        }, 5000);

        //Makes sure that the server notices that the player disconnects.
        //Otherwise a refresh (on chromium based browsers) can lead to the server
        //thinking that there's already an open tab with this lobby.
        window.onbeforeunload = () => {
            //Avoid unintentionally reestablishing connection.
            socket.onclose = null;
            socket.close();
        };

        const messageInput = document.getElementById("message-input");
        const playerContainer = document.getElementById("player-container");
        const wordContainer = document.getElementById("word-container");
        const chat = document.getElementById("chat");
        const messageContainer = document.getElementById("message-container");
        const roundSpan = document.getElementById("rounds");
        const maxRoundSpan = document.getElementById("max-rounds");
        const timeLeftValue = document.getElementById("time-left-value");
        const drawingBoard = document.getElementById("drawing-board");

        const centerDialogs = document.getElementById("center-dialogs");

        const waitChooseDialog = document.getElementById("waitchoose-dialog");
        const waitChooseDrawerSpan = document.getElementById("waitchoose-drawer");
        const namechangeDialog = document.getElementById("namechange-dialog");
        const namechangeFieldStartDialog = document.getElementById("namechange-field-start-dialog");
        const namechangeField = document.getElementById("namechange-field");

        const lobbySettingsButton = document.getElementById("lobby-settings-button");
        const kickButton = document.getElementById("kick-button");
        const lobbySettingsDialog = document.getElementById("lobbysettings-dialog");

        const startDialog = document.getElementById("start-dialog");
        const forceStartButton = document.getElementById("force-start-button");
        const gameOverDialog = document.getElementById("game-over-dialog");
        const gameOverDialogTitle = document.getElementById("game-over-dialog-title");
        const gameOverScoreboard = document.getElementById("game-over-scoreboard");
        const restartButton = document.getElementById("restart-button");
        const wordDialog = document.getElementById("word-dialog");
        const wordPreSelected = document.getElementById("word-preselected")
        const wordButtonContainer = document.getElementById("word-button-container");

        const kickDialog = document.getElementById("kick-dialog");
        const kickDialogPlayers = document.getElementById("kick-dialog-players");

        const soundToggleLabel = document.getElementById("sound-toggle-label");
        let sound = localStorage.getItem("sound") !== "false";
        updateSoundIcon();

        const set_dummy_word_hints = () => {
            // Dummy wordhint to prevent layout changes.
            applyWordHints([{
                character: 'D',
                underline: true,
            }], true);
        };
        set_dummy_word_hints();

        function showTextDialog(id, title, message) {
            const messageNode = document.createElement("span");
            messageNode.innerText = message;
            showDialog(id, title, messageNode);
        }

        const menu = document.getElementById("menu");
        function hideMenu() {
            menu.hidePopover();
        }

        // Since chromes implementation of the popup is dumb, we can't position
        // it correctly without javascript.
        if (!navigator.userAgent.toLowerCase().includes('firefox')) {
            const menu_button = document.getElementById("menu-button");
            menu.addEventListener("toggle", (event) => {
                if (event.newState === "open") {
                    const bounds = menu_button.getBoundingClientRect();
                    // Technically this won't correctly handle the scrolling
                    // position, but we'll cope for now.
                    menu.style.top = bounds.bottom + "px"
                    menu.style.left = bounds.left + "px"
                }
            });
        }

        function showDialog(id, title, contentNode, buttonBar) {
            hideMenu();

            const newDialog = document.createElement("div");
            newDialog.classList.add("center-dialog");
            if (id && id !== "") {
                newDialog.id = id;
            }

            const dialogTitle = document.createElement("span");
            dialogTitle.classList.add("dialog-title");
            dialogTitle.innerText = title;
            newDialog.appendChild(dialogTitle);

            const dialogContent = document.createElement("div");
            dialogContent.classList.add("center-dialog-content");
            dialogContent.appendChild(contentNode);
            newDialog.appendChild(dialogContent);

            if (buttonBar !== null && buttonBar !== undefined) {
                newDialog.appendChild(buttonBar);
            }

            newDialog.style.visibility = "visible";
            centerDialogs.appendChild(newDialog);
        }

        // Shows an information dialog with a button that closes the dialog and
        // removes it from the DOM.
        function showInfoDialog(title, message, buttonText) {
            const dialogId = "info_dialog";
            closeDialog(dialogId);

            const closeButton = createDialogButton(buttonText);
            closeButton.addEventListener("click", event => {
                closeDialog(dialogId)
            })

            const messageNode = document.createElement("span");
            messageNode.innerText = message;

            showDialog(dialogId, title, messageNode, createDialogButtonBar(closeButton));
        }

        function createDialogButton(text) {
            const button = document.createElement("button");
            button.innerText = text;
            button.classList.add("dialog-button");
            return button;
        }

        function createDialogButtonBar(...buttons) {
            const buttonBar = document.createElement("div");
            buttonBar.classList.add("button-bar");
            buttons.forEach(button => buttonBar.appendChild(button));
            return buttonBar;
        }

        function closeDialog(id) {
            const dialog = document.getElementById(id);
            if (dialog !== undefined && dialog !== null) {
                const parent = dialog.parentElement;
                if (parent !== undefined && parent !== null) {
                    parent.removeChild(dialog);
                }
            }
        }

        const helpDialogId = "help-dialog";
        function showHelpDialog() {
            closeDialog(helpDialogId);
            const controlsLabel = document.createElement("b");
            controlsLabel.innerText = '{{.Translation.Get "controls"}}';

            const controlsTextOne = document.createElement("p");
            controlsTextOne.innerText = '{{.Translation.Get "switch-tools-intro"}}:';

            const controlsTextTwo = document.createElement("p");
            controlsTextTwo.innerHTML = '{{.Translation.Get "pencil"}}: <kbd>Q</kbd><br/>' +
                '{{.Translation.Get "fill-bucket"}}: <kbd>W</kbd><br/>' +
                '{{.Translation.Get "eraser"}}: <kbd>E</kbd><br/>';

            const controlsTextThree = document.createElement("p");
            controlsTextThree.innerHTML = '{{printf (.Translation.Get "switch-pencil-sizes") "<kbd>1</kbd>" "<kbd>4</kbd>"}}';

            const closeButton = createDialogButton('{{.Translation.Get "close"}}');
            closeButton.addEventListener("click", event => {
                closeDialog(helpDialogId)
            })

            const footer = document.createElement("div");
            footer.className = "help-footer";
            footer.innerHTML = `{{template "footer" . }}`;

            const buttonBar = createDialogButtonBar(closeButton);

            const dialogContent = document.createElement("div");
            dialogContent.appendChild(controlsLabel)
            dialogContent.appendChild(controlsTextOne);
            dialogContent.appendChild(controlsTextTwo);
            dialogContent.appendChild(controlsTextThree);
            dialogContent.appendChild(footer);

            showDialog(helpDialogId, '{{.Translation.Get "help"}}', dialogContent, buttonBar);
        }

        function showKickDialog() {
            hideMenu();

            if (cachedPlayers && cachedPlayers) {
                kickDialogPlayers.innerHTML = "";

                cachedPlayers.forEach(player => {
                    //Don't wanna allow kicking ourselves.
                    if (player.id !== ownID && player.connected) {
                        const playerKickEntry = document.createElement("button");
                        playerKickEntry.classList.add("kick-player-button");
                        playerKickEntry.classList.add("dialog-button");
                        playerKickEntry.onclick = () => onVotekickPlayer(player.id);
                        playerKickEntry.innerText = player.name;
                        kickDialogPlayers.appendChild(playerKickEntry);
                    }
                });

                kickDialog.style.visibility = "visible";
            }
        }

        function hideKickDialog() {
            kickDialog.style.visibility = "hidden";
        }

        function showNameChangeDialog() {
            hideMenu();

            namechangeDialog.style.visibility = "visible";
            namechangeField.focus();
        }

        function hideNameChangeDialog() {
            namechangeDialog.style.visibility = "hidden";
        }

        function changeName(name) {
            //Avoid unnecessary traffic.
            if (name !== ownName) {
                socket.send(JSON.stringify({
                    type: "name-change",
                    data: name,
                }));
            }
        }

        function setUsernameLocally(name) {
            ownName = name;
            namechangeFieldStartDialog.value = name;
            namechangeField.value = name;
        }

        function toggleFullscreen() {
            if (document.fullscreen) {
                document.exitFullscreen();
            } else {
                document.body.requestFullscreen();
            }
        }

        function showLobbySettingsDialog() {
            hideMenu();
            lobbySettingsDialog.style.visibility = "visible";
        }

        function hideLobbySettingsDialog() {
            lobbySettingsDialog.style.visibility = "hidden";
        }

        function saveLobbySettings() {
            fetch("{{.RootPath}}/v1/lobby/{{.LobbyID}}?" + new URLSearchParams({
                drawing_time: document.getElementById("lobby-settings-drawing-time").value,
                rounds: document.getElementById("lobby-settings-max-rounds").value,
                public: document.getElementById("lobby-settings-public").checked,
                max_players: document.getElementById("lobby-settings-max-players").value,
                clients_per_ip_limit: document.getElementById("lobby-settings-clients-per-ip-limit").value,
                custom_words_per_turn: document.getElementById("lobby-settings-custom-words-per-turn").value,
            }), {
                method: 'PATCH',
            })
                .then(result => {
                    if (result.status === 200) {
                        hideLobbySettingsDialog();
                    } else {
                        result
                            .text()
                            .then(bodyText => {
                                alert("Error saving lobby settings: \n\n - " + bodyText.replace(";", "\n - "));
                            });
                    }
                });
        }

        function toggleSound() {
            sound = !sound;
            localStorage.setItem("sound", sound.toString());
            updateSoundIcon();
        }

        function updateSoundIcon() {
            if (sound) {
                soundToggleLabel.src = "{{.RootPath}}/resources/sound.svg?cache_bust={{.CacheBust}}";
            } else {
                soundToggleLabel.src = "{{.RootPath}}/resources/no-sound.svg?cache_bust={{.CacheBust}}";
            }
        }

        //The drawing board has a base size. This base size results in a certain ratio
        //that the actual canvas has to be resized accordingly too. This is needed
        //since not every client has the same screensize.
        const baseWidth = {{.DrawingBoardBaseWidth}};
        const baseHeight = {{.DrawingBoardBaseHeight}};
        const boardRatio = baseWidth / baseHeight;

        // Moving this here to extract the context after resizing
        const context = drawingBoard.getContext("2d", {alpha: false});

        // One might one wonder what the fuck is going here. I'll enlighten you!
        // The data you put into a canvas, might not necessarily be what comes out
        // of it again. Some browser (*cough* firefox *cough*) seem to put little
        // off by one / two errors into the data, when reading it back out.
        // Apparently this helps against some type of fingerprinting. In order to
        // combat this, we do not use the canvas as a source of truth, but
        // permanently hold a virtual canvas buffer that we can operate on when
        // filling or drawing.
        let imageData;

        function scaleUpFactor() {
            return baseWidth / drawingBoard.clientWidth;
        }

        // Will convert the value to the server coordinate space.
        // The canvas locally can be bigger or smaller. Depending on the base
        // values and the local values, we'll either have a value slightly
        // higher or lower than 1.0. Since we draw on a virtual canvas, we have
        // to use the server coordinate space, which then gets scaled by the
        // canvas API of the browser, as we have a different clientWidth than
        // width and clientHeight than height.
        function convertToServerCoordinate(value) {
            return Math.round(parseFloat(scaleUpFactor() * value));
        }

        const pen = 0;
        const rubber = 1;
        const fillBucket = 2;

        let allowDrawing = false;
        let spectating = false;
        let spectateRequested = false;

        //Initially, we require some values to avoid running into nullpointers
        //or undefined errors. The specific values don't really matter.
        let localTool = pen;
        let localLineWidth = 8;

        //Those are not scaled for now, as the whole toolbar would then have to incorrectly size up and down.
        const sizeButton8 = document.getElementById("size-8-button");
        const sizeButton16 = document.getElementById("size-16-button");
        const sizeButton24 = document.getElementById("size-24-button");
        const sizeButton32 = document.getElementById("size-32-button");
        const sizeButtons = document.getElementById("size-buttons");

        const toolButtonPen = document.getElementById("tool-type-pencil");
        const toolButtonRubber = document.getElementById("tool-type-rubber");
        const toolButtonFill = document.getElementById("tool-type-fill");

        if (sizeButton8.checked) {
            setLineWidthNoUpdate(8);
        } else if (sizeButton16.checked) {
            setLineWidthNoUpdate(16);
        } else if (sizeButton24.checked) {
            setLineWidthNoUpdate(24);
        } else if (sizeButton32.checked) {
            setLineWidthNoUpdate(32);
        }

        if (toolButtonPen.checked) {
            chooseToolNoUpdate(pen);
        } else if (toolButtonFill.checked) {
            chooseToolNoUpdate(fillBucket);
        } else if (toolButtonRubber.checked) {
            chooseToolNoUpdate(rubber);
        }

        let localColor, localColorIndex;

        function setColor(index) {
            setColorNoUpdate(index);

            // If we select a new color, we assume we don't want to use the
            // rubber anymore and automatically switch to the pen.
            if (localTool === rubber) {
                // Clicking the button programmatically won't trigger its
                toolButtonPen.click();

                // updateDrawingStateUI is implicit
                chooseTool(pen);
            } else {
                updateDrawingStateUI();
            }
        }

        function setColorNoUpdate(index) {
            localColorIndex = index;
            localColor = indexToRgbColor(index);
            sessionStorage.setItem("local_color", JSON.stringify(index));
        }

        setColorNoUpdate(JSON.parse(sessionStorage.getItem("local_color")) ?? 13 /* black*/);
        updateDrawingStateUI();

        function setLineWidth(value) {
            setLineWidthNoUpdate(value);
            updateDrawingStateUI();
        }

        function setLineWidthNoUpdate(value) {
            localLineWidth = value;
        }

        function chooseTool(value) {
            chooseToolNoUpdate(value);
            updateDrawingStateUI();
        }

        function chooseToolNoUpdate(value) {
            if (value === pen || value === rubber || value === fillBucket) {
                localTool = value;
            } else {
                //If this ends up with an invalid value, we use the pencil.
                localTool = pen;
            }
        }

        function rgbColorObjectToHexString(color) {
            return "#"
                + numberTo16BitHexadecimal(color.r)
                + numberTo16BitHexadecimal(color.g)
                + numberTo16BitHexadecimal(color.b);
        }

        function numberTo16BitHexadecimal(number) {
            return Number(number).toString(16).padStart(2, "0");
        }

        const rubberColor = {r: 255, g: 255, b: 255};

        function updateDrawingStateUI() {
            // Color all buttons, so the player always has a hint as to what the
            // active color is, since the cursor might not always be visible.
            sizeButtons.style.setProperty("--dot-color", rgbColorObjectToHexString(localColor));

            updateCursor();
        }

        function updateCursor() {
            if (allowDrawing) {
                if (localTool === rubber) {
                    setCircleCursor(rubberColor, localLineWidth);
                } else if (localTool === fillBucket) {
                    const outerColor = getComplementaryCursorColor(localColor);
                    drawingBoard.style.cursor = `url('data:image/svg+xml;utf8,`
                        + encodeURIComponent(
                            `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="32" width="32">`
                            + generateSVGCircle(8, localColor, outerColor)
                            //This has been taken from fill.svg
                            + `
                                <svg viewBox="0 0 64 64" x="8" y="8" height="24" width="24">
                                    <path
                                        d="m 59.575359,58.158246 c 0,1.701889 -1.542545,3.094345 -3.427877,3.094345 H 8.1572059 c -1.8853322,0 -3.4278772,-1.392456 -3.4278772,-3.094345 V 5.5543863 c 0,-1.7018892 1.542545,-3.0943445 3.4278772,-3.0943445 H 56.147482 c 1.885332,0 3.427877,1.3924553 3.427877,3.0943445 z"
                                        id="path8"
                                        style="stroke-width:1.62842;fill:#b3b3b3" />
                                    <path
                                        d="M 56.147482,2.4600418 H 8.1572059 c -1.8853322,0 -3.4278772,1.3152251 -3.4278772,2.9227219 V 14.15093 c 0,1.607497 0,0 0,0 l 26.5660453,2.922722 c 0.685576,0 2.570908,0.584545 2.570908,1.89977 0,0 0,1.899769 0,2.484313 0,1.169089 1.199758,2.192042 2.570908,2.192042 1.371151,0 2.570908,-1.022953 2.570908,-2.192042 0,-1.169089 1.199756,-2.192041 2.570908,-2.192041 1.37115,0 2.570907,1.022952 2.570907,2.192041 v 19.728374 c 0,1.169089 1.199757,2.192042 2.570908,2.192042 1.37115,0 2.570907,-1.022953 2.570907,-2.192042 V 25.841818 c 0,-1.169088 1.199758,-2.192041 2.570908,-2.192041 1.371151,0 2.570908,1.022953 2.570908,2.192041 v 3.653404 c 0,1.169088 1.199756,2.192041 2.570907,2.192041 1.371151,0 2.570908,-1.022953 2.570908,-2.192041 V 5.3827637 c 0,-1.6074968 -1.542545,-2.9227219 -3.427877,-2.9227219 z"
                                        id="path12"
                                        style="stroke-width:1.58262;fill:#C75C5C" />
                                    <path
                                        d="m 60.432329,6.1134441 c 0,13.2983859 -12.683145,24.1124579 -28.279986,24.1124579 -15.596839,0 -28.2799836,-10.814072 -28.2799836,-24.1124579"
                                        id="path18"
                                        style="fill:none;stroke:#4F5D73;stroke-width:2;stroke-linecap:round;stroke-miterlimit:10" />
                                </svg>
                            </svg>`
                        )
                        + `') 4 4, auto`;
                } else {
                    setCircleCursor(localColor, localLineWidth);
                }
            } else {
                drawingBoard.style.cursor = 'not-allowed';
            }
        }

        function getComplementaryCursorColor(innerColor) {
            const hsp = Math.sqrt(
                0.299 * (innerColor.r * innerColor.r) +
                0.587 * (innerColor.g * innerColor.g) +
                0.114 * (innerColor.b * innerColor.b)
            );

            if (hsp > 127.5) {
                return {r: 0, g: 0, b: 0};
            }

            return {r: 255, g: 255, b: 255};
        }

        function setCircleCursor(innerColor, size) {
            const outerColor = getComplementaryCursorColor(innerColor);
            const circleSize = size;
            drawingBoard.style.cursor = `url('data:image/svg+xml;utf8,`
                + encodeURIComponent(
                    `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="32" height="32">`
                    + generateSVGCircle(circleSize, innerColor, outerColor) + `</svg>')`
                )
                + ` ` + (circleSize / 2) + ` ` + (circleSize / 2) + `, auto`;
        }

        function generateSVGCircle(circleSize, innerColor, outerColor) {
            const circleRadius = (circleSize / 2);
            const innerColorCSS = "rgb(" + innerColor.r + "," + innerColor.g + "," + innerColor.b + ")";
            const outerColorCSS = "rgb(" + outerColor.r + "," + outerColor.g + "," + outerColor.b + ")";
            return `<circle cx="` + circleRadius + `" cy="` + circleRadius + `" r="` + circleRadius + `" style="fill: ` + innerColorCSS + `; stroke: ` + outerColorCSS + `;"/>`;
        }

        function toggleSpectate() {
            socket.send(JSON.stringify({
                type: "toggle-spectate",
            }));
        }

        function setSpectateMode(requestedValue, spectatingValue) {
            const modeUnchanged = spectatingValue === spectating;
            const requestUnchanged = requestedValue === spectateRequested;
            if (modeUnchanged && requestUnchanged) {
                return;
            }

            if (spectateRequested && !requestedValue && modeUnchanged) {
                showInfoDialog(
                    '{{.Translation.Get "spectation-request-cancelled-title"}}',
                    '{{.Translation.Get "spectation-request-cancelled-text"}}',
                    "Okay");
            } else if (spectateRequested && !requestedValue && modeUnchanged) {
                showInfoDialog(
                    '{{.Translation.Get "participation-request-cancelled-title"}}',
                    '{{.Translation.Get "participation-request-cancelled-text"}}',
                    "Okay");
            } else if (!spectateRequested && requestedValue && !spectatingValue) {
                showInfoDialog(
                    '{{.Translation.Get "spectation-requested-title"}}',
                    '{{.Translation.Get "spectation-requested-text"}}',
                    "Okay");
            } else if (!spectateRequested && requestedValue && spectatingValue) {
                showInfoDialog(
                    '{{.Translation.Get "participation-requested-title"}}',
                    '{{.Translation.Get "participation-requested-text"}}',
                    "Okay");
            } else if (spectatingValue && !spectating) {
                showInfoDialog(
                    '{{.Translation.Get "now-spectating-title"}}',
                    '{{.Translation.Get "now-spectating-text"}}',
                    "Okay");
            } else if (!spectatingValue && spectating) {
                showInfoDialog(
                    '{{.Translation.Get "now-participating-title"}}',
                    '{{.Translation.Get "now-participating-text"}}',
                    "Okay");
            }

            spectateRequested = requestedValue;
            spectating = spectatingValue;
        }

        function toggleReadiness() {
            socket.send(JSON.stringify({
                type: "toggle-readiness",
            }));
        }

        function startGame() {
            socket.send(JSON.stringify({
                type: "start",
            }));
        }

        function clearCanvasAndSendEvent() {
            if (allowDrawing) {
                //Avoid unnecessary traffic back to us and handle the clear directly.
                clear(context);
                socket.send(JSON.stringify({
                    type: "clear-drawing-board"
                }));
            }
        }

        function undoAndSendEvent() {
            if (allowDrawing) {
                socket.send(JSON.stringify({
                    type: "undo"
                }));
            }
        }

        //Used to restore the last message on arrow up.
        let lastMessage = "";

        const encoder = new TextEncoder();
        function sendMessage(event) {
            if (event.keyCode !== 13) {
                return;
            }
            if (!messageInput.value) {
                return;
            }

            // While the backend already checks for message length, we want to
            // prevent the loss of input and omit the event / clear here.
            if (encoder.encode(messageInput.value).length > 10000) {
                appendMessage("system-message", '{{.Translation.Get "system"}}',
                    '{{.Translation.Get "message-too-long"}}');
                //We keep the messageInput content, since it could've been
                //something important and we don't want the user having to
                //rewrite it. Instead they can send it via some other means
                //or shorten it a bit.
                return;
            }

            socket.send(JSON.stringify({
                type: "message",
                data: messageInput.value
            }));
            lastMessage = messageInput.value;
            messageInput.value = "";
        }

        messageInput.addEventListener("keydown", function (event) {
            if (event.keyCode === 38 /* arrow up */ && messageInput.value.length === 0) {
                messageInput.value = lastMessage;
            }
        });

        function setAllowDrawing(value) {
            allowDrawing = value;
            updateDrawingStateUI();

            if (allowDrawing) {
                document.getElementById("toolbox").style.display = "flex";
            } else {
                document.getElementById("toolbox").style.display = "none";
            }
        }

        function chooseWord(index) {
            socket.send(JSON.stringify({
                type: "choose-word",
                data: index
            }));
            setAllowDrawing(true);
            wordDialog.style.visibility = "hidden";
        }

        function onVotekickPlayer(playerId) {
            socket.send(JSON.stringify({
                type: "kick-vote",
                data: playerId
            }));
            hideKickDialog();
        }

        //This automatically scrolls down the chat on arrivals of new messages
        new MutationObserver(() => messageContainer.scrollTop = messageContainer.scrollHeight)
            .observe(messageContainer, {
                attributes: false,
                childList: true,
                subtree: false
            });

        let ownID, ownerID, ownName, drawerID, drawerName;
        let round = 0;
        let rounds = 0;
        let roundEndTime = 0;
        let gameState = "unstarted";
        let drawingTimeSetting = "âˆž";

        function registerMessageHandler(targetSocket) {
            targetSocket.onmessage = event => {
                const parsed = JSON.parse(event.data);
                if (parsed.type === "ready") {
                    handleReadyEvent(parsed.data);
                } else if (parsed.type === "game-over") {
                    let ready = parsed.data;
                    showRoundEndMessage(ready.previousWord);
                    handleReadyEvent(ready);
                } else if (parsed.type === "update-players") {
                    applyPlayers(parsed.data);
                } else if (parsed.type === "name-change") {
                    const player = getCachedPlayer(parsed.data.playerId);
                    if (player !== null) {
                        player.name = parsed.data.playerName;
                    }

                    const playernameSpan = document.getElementById("playername-" + parsed.data.playerId);
                    if (playernameSpan !== null) {
                        playernameSpan.innerText = parsed.data.playerName;
                    }
                    if (parsed.data.playerId === ownID) {
                        setUsernameLocally(parsed.data.playerName);
                    }
                    if (parsed.data.playerId === drawerID) {
                        waitChooseDrawerSpan.innerText = parsed.data.playerName;
                    }
                } else if (parsed.type === "correct-guess") {
                    playWav('{{.RootPath}}/resources/plop.wav?cache_bust={{.CacheBust}}');

                    if (parsed.data === ownID) {
                        appendMessage("correct-guess-message", null, '{{.Translation.Get "correct-guess"}}');
                    } else {
                        const player = getCachedPlayer(parsed.data)
                        if (player !== null) {
                            appendMessage("correct-guess-message-other-player", null, '{{.Translation.Get "correct-guess-other-player"}}'.format(player.name));
                        }
                    }
                } else if (parsed.type === "close-guess") {
                    appendMessage("close-guess-message", null, '{{.Translation.Get "close-guess"}}'.format(parsed.data));
                } else if (parsed.type === "update-wordhint") {
                    wordDialog.style.visibility = "hidden";
                    waitChooseDialog.style.visibility = "hidden";
                    applyWordHints(parsed.data);
                } else if (parsed.type === "message") {
                    appendMessage(null, parsed.data.author, parsed.data.content);
                } else if (parsed.type === "system-message") {
                    appendMessage("system-message", '{{.Translation.Get "system"}}', parsed.data);
                } else if (parsed.type === "non-guessing-player-message") {
                    appendMessage("non-guessing-player-message", parsed.data.author, parsed.data.content);
                } else if (parsed.type === "line") {
                    drawLine(
                        context,
                        imageData,
                        parsed.data.x, parsed.data.y,
                        parsed.data.x2, parsed.data.y2,
                        indexToRgbColor(parsed.data.color),
                        parsed.data.width);
                } else if (parsed.type === "fill") {
                    if (floodfillUint8ClampedArray(
                        imageData.data,
                        parsed.data.x,
                        parsed.data.y,
                        indexToRgbColor(parsed.data.color),
                        imageData.width,
                        imageData.height)) {
                        context.putImageData(imageData, 0, 0);
                    }
                } else if (parsed.type === "clear-drawing-board") {
                    clear(context);
                } else if (parsed.type === "word-chosen") {
                    wordDialog.style.visibility = "hidden";
                    waitChooseDialog.style.visibility = "hidden";
                    setRoundTimeLeft(parsed.data.timeLeft);
                    applyWordHints(parsed.data.hints);
                    setAllowDrawing(drawerID === ownID);
                } else if (parsed.type === "next-turn") {
                    if (gameState === "ongoing") {
                        //The previous turn has ended.
                        showRoundEndMessage(parsed.data.previousWord);
                    } else {
                        //First turn, the game starts
                        gameState = "ongoing";
                    }

                    //As soon as a turn starts, the round should be ongoing, so we make
                    //sure that all types of dialogs, that indicate the game isn't
                    //ongoing, are not visible anymore.
                    startDialog.style.visibility = "hidden";
                    restartButton.style.display = "none";
                    gameOverDialog.style.visibility = "hidden";

                    //If a player doesn't choose, the dialog will still be up.
                    wordDialog.style.visibility = "hidden";
                    playWav('{{.RootPath}}/resources/end-turn.wav?cache_bust={{.CacheBust}}');

                    clear(context);

                    round = parsed.data.round;
                    updateRoundsDisplay();
                    setRoundTimeLeft(parsed.data.choiceTimeLeft);
                    applyPlayers(parsed.data.players);

                    set_dummy_word_hints();

                    //Even though we always hide the dialog in the "your-turn"
                    //event handling, it will be shortly visible if we it here.
                    if (drawerID !== ownID) {
                        //Show additional dialog, that another user (drawer) is choosing a word
                        waitChooseDrawerSpan.innerText = drawerName;
                        waitChooseDialog.style.visibility = "visible";
                    }

                    setAllowDrawing(false);
                } else if (parsed.type === "your-turn") {
                    playWav('{{.RootPath}}/resources/your-turn.wav?cache_bust={{.CacheBust}}');
                    //This dialog could potentially stay visible from last
                    //turn, in case nobody has chosen a word.
                    waitChooseDialog.style.visibility = "hidden";
                    promptWords(parsed.data);
                } else if (parsed.type === "drawing") {
                    applyDrawData(parsed.data);
                } else if (parsed.type === "kick-vote") {
                    if (parsed.data.playerId === ownID && parsed.data.voteCount >= parsed.data.requiredVoteCount) {
                        alert('{{.Translation.Get "self-kicked"}}');
                        document.location.href = "{{.RootPath}}/";
                    } else {
                        let kickMessage = '{{.Translation.Get "kick-vote"}}'.format(parsed.data.voteCount, parsed.data.requiredVoteCount, parsed.data.playerName);
                        if (parsed.data.voteCount >= parsed.data.requiredVoteCount) {
                            kickMessage += ' {{.Translation.Get "player-kicked"}}';
                        }
                        appendMessage("system-message", '{{.Translation.Get "system"}}', kickMessage);
                    }
                } else if (parsed.type === "owner-change") {
                    ownerID = parsed.data.playerId;
                    updateButtonVisibilities();
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "owner-change"}}'.format(parsed.data.playerName));
                } else if (parsed.type === "drawer-kicked") {
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "drawer-kicked"}}');
                } else if (parsed.type === "lobby-settings-changed") {
                    rounds = parsed.data.rounds;
                    updateRoundsDisplay();
                    updateButtonVisibilities();
                    appendMessage("system-message", '{{.Translation.Get "system"}}', '{{.Translation.Get "lobby-settings-changed"}}\n\n'
                        + '{{.Translation.Get "drawing-time-setting"}}: ' + parsed.data.drawingTime + "\n"
                        + '{{.Translation.Get "rounds-setting"}}: ' + parsed.data.rounds + "\n"
                        + '{{.Translation.Get "public-lobby-setting"}}: ' + parsed.data.public + "\n"
                        + '{{.Translation.Get "max-players-setting"}}: ' + parsed.data.maxPlayers + "\n"
                        + '{{.Translation.Get "custom-words-per-turn-setting"}}: ' + parsed.data.customWordsPerTurn + "%\n"
                        + '{{.Translation.Get "players-per-ip-limit-setting"}}: ' + parsed.data.clientsPerIpLimit);
                } else if (parsed.type === "shutdown") {
                    socket.onclose = null;
                    socket.close();
                    showDialog("shutdown-info", "Server shutting down",
                        document.createTextNode("Sorry, but the server is about to shut down. Please come back at a later time."));
                }
            }
        };

        function showRoundEndMessage(previousWord) {
            if (previousWord === "") {
                appendMessage("system-message", null, '{{.Translation.Get "round-over"}}');
            } else {
                appendMessage("system-message", null, '{{.Translation.Get "round-over-no-word"}}'.format(previousWord));
            }
        }

        function getCachedPlayer(playerID) {
            if (!cachedPlayers) {
                return null;
            }

            for (let i = 0; i < cachedPlayers.length; i++) {
                let player = cachedPlayers[i];
                if (player.id === playerID) {
                    return player;
                }
            }

            return null;
        }

        //In the initial implementation we used a timestamp to know when
        //the round will end. The problem with that approach was that the
        //clock on client and server was often not in sync. The second
        //approach was to instead send milliseconds left and keep counting
        //them down each 500 milliseconds. The problem with this approach, was
        //that there could potentially be timing mistakes while counting down.
        //What we do instead is use our local date, add the timeLeft to it and
        //repeatdly recaculate the timeLeft using the roundEndTime and the
        //current time. This way we won't have any calculation errors.
        //
        //FIXME The only leftover issue is that ping isn't taken into
        //account, however, that's no biggie for now.
        function setRoundTimeLeft(timeLeftMs) {
            roundEndTime = Date.now() + timeLeftMs;
        }

        function handleReadyEvent(ready) {
            ownerID = ready.ownerId;
            ownID = ready.playerId;

            setRoundTimeLeft(ready.timeLeft);
            setUsernameLocally(ready.playerName);
            setAllowDrawing(ready.allowDrawing);
            round = ready.round;
            rounds = ready.rounds;
            gameState = ready.gameState;
            drawingTimeSetting = ready.drawingTimeSetting;
            updateRoundsDisplay();
            updateButtonVisibilities();

            if (ready.players && ready.players.length) {
                applyPlayers(ready.players);
            }
            if (ready.currentDrawing && ready.currentDrawing.length) {
                applyDrawData(ready.currentDrawing);
            }
            if (ready.wordHints && ready.wordHints.length) {
                applyWordHints(ready.wordHints);
            } else {
                set_dummy_word_hints();
            }

            if (ready.gameState === "unstarted") {
                startDialog.style.visibility = "visible";
                if (ownerID === ownID) {
                    forceStartButton.style.display = "block";
                } else {
                    forceStartButton.style.display = "none";
                }
            } else if (ready.gameState === "gameOver") {
                gameOverDialog.style.visibility = "visible";
                if (ownerID === ownID) {
                    restartButton.style.display = "block";
                }

                gameOverScoreboard.innerHTML = "";

                //Copying array so we can sort.
                const players = cachedPlayers.slice();
                players.sort((a, b) => {
                    return a.rank - b.rank;
                });

                //These two are required for displaying the "game over / win / tie" message.
                let countOfRankOnePlayers = 0;
                let isSelfRankOne = false;
                for (let i = 0; i < players.length; i++) {
                    const player = players[i];
                    if (!player.connected) {
                        continue;
                    }

                    if (player.rank === 1) {
                        countOfRankOnePlayers++;
                        if (player.id === ownID) {
                            isSelfRankOne = true;
                        }
                    }

                    //Even if we don't want to show a player-entry, we still need to iterate
                    //over all players to handle the dialog titles.
                    if (player.rank <= 5) {
                        const newScoreboardEntry = document.createElement("div");
                        newScoreboardEntry.classList.add("gameover-scoreboard-entry");
                        if (player.id === ownID) {
                            newScoreboardEntry.classList.add("gameover-scoreboard-entry-self");
                        }

                        const scoreboardRankDiv = document.createElement("div");
                        scoreboardRankDiv.classList.add("gameover-scoreboard-rank");
                        scoreboardRankDiv.innerText = player.rank;
                        newScoreboardEntry.appendChild(scoreboardRankDiv);

                        const scoreboardNameDiv = document.createElement("div");
                        scoreboardNameDiv.classList.add("gameover-scoreboard-name");
                        scoreboardNameDiv.innerText = player.name;
                        newScoreboardEntry.appendChild(scoreboardNameDiv);

                        const scoreboardScoreSpan = document.createElement("span");
                        scoreboardScoreSpan.classList.add("gameover-scoreboard-score");
                        scoreboardScoreSpan.innerText = player.score;
                        newScoreboardEntry.appendChild(scoreboardScoreSpan);

                        gameOverScoreboard.appendChild(newScoreboardEntry);
                    }
                }

                if (isSelfRankOne) {
                    if (countOfRankOnePlayers >= 2) {
                        gameOverDialogTitle.innerText = '{{.Translation.Get "game-over-tie"}}';
                    } else {
                        gameOverDialogTitle.innerText = '{{.Translation.Get "game-over-win"}}';
                    }
                } else {
                    gameOverDialogTitle.innerText = '{{.Translation.Get "game-over"}}'.format(player.rank, player.score);
                }
            } else if (ready.gameState === "ongoing") {
                // Lack of wordHints implies that word has been chosen yet.
                if (!ready.wordHints && drawerID !== ownID) {
                    waitChooseDrawerSpan.innerText = drawerName;
                    waitChooseDialog.style.visibility = "visible";
                }
            }
        }

        function updateButtonVisibilities() {
            if (ownerID === ownID) {
                lobbySettingsButton.style.display = "flex";
            } else {
                lobbySettingsButton.style.display = "none";
            }
        }

        function promptWords(data) {
            wordPreSelected.textContent = data.words[data.preSelectedWord];
            wordButtonContainer.replaceChildren(...data.words.map((word, index) => {
                const button = createDialogButton(word);
                button.onclick = () => {
                    chooseWord(index);
                };
                return button;
            }));
            wordDialog.style.visibility = "visible";
        }

        function playWav(file) {
            if (sound) {
                const audio = new Audio(file);
                audio.type = 'audio/wav';
                audio.play();
            }
        }

        window.setInterval(() => {
            if (gameState === "ongoing") {
                const msLeft = roundEndTime - Date.now();
                const secondsLeft = Math.max(0, Math.floor(msLeft / 1000));
                timeLeftValue.innerText = "" + secondsLeft
            } else {
                timeLeftValue.innerText = "âˆž";
            }
        }, 500);

        //appendMessage adds a new message to the message container. If the
        //message amount is too high, we cut off a part of the messages to
        //prevent lagging and useless memory usage.
        function appendMessage(styleClass, author, message) {
            if (messageContainer.childElementCount >= 100) {
                messageContainer.removeChild(messageContainer.firstChild);
            }

            const newMessageDiv = document.createElement("div");
            newMessageDiv.classList.add("message");
            if (styleClass !== null && styleClass !== "") {
                newMessageDiv.classList.add(styleClass);
            }

            if (author !== null && author !== "") {
                const authorNameSpan = document.createElement("span");
                authorNameSpan.classList.add("chat-name");
                authorNameSpan.innerText = author;
                newMessageDiv.appendChild(authorNameSpan);
            }

            const messageSpan = document.createElement("span");
            messageSpan.classList.add("message-content");
            messageSpan.innerText = message;
            newMessageDiv.appendChild(messageSpan);

            messageContainer.appendChild(newMessageDiv);
        }

        let cachedPlayers;

        //applyPlayers takes the players passed, assigns them to cachedPlayers,
        //refreshes the scoreboard and updates the drawerID and drawerName variables.
        function applyPlayers(players) {
            const matchOngoing = gameState === "ongoing";
            if (!matchOngoing) {
                let readyPlayers = 0;
                let readyPlayersRequired = 0;

                players.forEach(player => {
                    if (!player.connected || player.state === "spectating") {
                        return;
                    }

                    readyPlayersRequired = readyPlayersRequired + 1;
                    if (player.state === "ready") {
                        readyPlayers = readyPlayers + 1;
                    }

                    if (player.id === ownID) {
                        document.getElementById("ready-state-start").checked = player.state === "ready";
                        document.getElementById("ready-state-game-over").checked = player.state === "ready";
                    }
                });

                const readyCounts = document.getElementsByClassName("ready-count");
                const reaadyNeededs = document.getElementsByClassName("ready-needed");

                Array.from(readyCounts).forEach((element) => {
                    element.innerText = readyPlayers.toString();
                });
                Array.from(reaadyNeededs).forEach((element) => {
                    element.innerText = readyPlayersRequired.toString();
                });
            }

            playerContainer.innerHTML = "";
            players.forEach(player => {
                // Makes sure that the "is choosing" a word dialog doesn't show
                // "undefined" as the player name. Can happen, if the player
                // disconnects after being assigned the drawer.
                if (matchOngoing && player.state === "drawing") {
                    drawerID = player.id;
                    drawerName = player.name;
                }

                //We don't wanna show the disconnected players.
                if (!player.connected) {
                    return;
                }

                if (player.id === ownID) {
                    setSpectateMode(player.spectateToggleRequested, player.state === "spectating");
                }

                const oldPlayer = getCachedPlayer(player.id);
                if (oldPlayer && oldPlayer.state === "spectating" && player.state !== "spectating") {
                    appendMessage(
                        "system-message",
                        '{{.Translation.Get "system"}}',
                        `${player.name} is now participating`);
                } else if (oldPlayer && oldPlayer.state !== "spectating" && player.state === "spectating") {
                    appendMessage(
                        "system-message",
                        '{{.Translation.Get "system"}}',
                        `${player.name} is now spectating`);
                }

                if (player.state === "spectating") {
                    return;
                }

                const playerDiv = document.createElement("div");

                playerDiv.classList.add("player");

                const scoreAndStatusDiv = document.createElement("div");
                scoreAndStatusDiv.classList.add("score-and-status");
                playerDiv.appendChild(scoreAndStatusDiv);

                const playerscoreDiv = document.createElement("div");
                playerscoreDiv.classList.add("playerscore-group");
                scoreAndStatusDiv.appendChild(playerscoreDiv);

                if (matchOngoing) {
                    if (player.state === "standby") {
                        playerDiv.classList.add("player-done");
                    } else if (player.state === "drawing") {
                        const playerStateImage = createPlayerStateImageNode("{{.RootPath}}/resources/pencil.svg?cache_bust={{.CacheBust}}");
                        playerStateImage.style.transform = "scaleX(-1)";
                        scoreAndStatusDiv.appendChild(playerStateImage);
                    } else if (player.state === "standby") {
                        const playerStateImage = createPlayerStateImageNode("{{.RootPath}}/resources/checkmark.svg?cache_bust={{.CacheBust}}");
                        scoreAndStatusDiv.appendChild(playerStateImage);
                    }
                } else {
                    if (player.state === "ready") {
                        playerDiv.classList.add("player-ready");
                    }
                }

                const rankSpan = document.createElement("span");
                rankSpan.classList.add("rank");
                rankSpan.innerText = player.rank;
                playerDiv.appendChild(rankSpan)

                const playernameSpan = document.createElement("span");
                playernameSpan.classList.add("playername");
                playernameSpan.innerText = player.name;
                playernameSpan.id = "playername-" + player.id;
                if (player.id === ownID) {
                    playernameSpan.classList.add("playername-self");
                }
                playerDiv.appendChild(playernameSpan);

                const playerscoreSpan = document.createElement("span");
                playerscoreSpan.classList.add("playerscore");
                playerscoreSpan.innerText = player.score;
                playerscoreDiv.appendChild(playerscoreSpan);

                const lastPlayerscoreSpan = document.createElement("span");
                lastPlayerscoreSpan.classList.add("last-turn-score");
                lastPlayerscoreSpan.innerText = '{{.Translation.Get "last-turn"}}'.format(player.lastScore);
                playerscoreDiv.appendChild(lastPlayerscoreSpan);

                playerContainer.appendChild(playerDiv);
            });

            // We do this at the end, so we can access the old values while
            // iterating over the new ones
            cachedPlayers = players;
        }

        function createPlayerStateImageNode(path) {
            const playerStateImage = document.createElement("img");
            playerStateImage.style.width = "1rem";
            playerStateImage.style.height = "1rem";
            playerStateImage.src = path;
            return playerStateImage;
        }
        function updateRoundsDisplay() {
            roundSpan.innerText = round;
            maxRoundSpan.innerText = rounds;
        }

        function applyWordHints(wordHints, dummy) {
            // We abuse the container to prevent the layout from jumping.
            if (!dummy) {
                wordContainer.style.visibility = "visible";
            } else {
                wordContainer.style.visibility = "hidden";
            }

            wordContainer.replaceChildren(...wordHints.map(hint => {
                const hintSpan = document.createElement("span");
                hintSpan.classList.add("hint");
                if (hint.character === 0) {
                    hintSpan.classList.add("hint-underline");
                    hintSpan.innerHTML = "&nbsp;";
                } else {
                    if (hint.underline) {
                        hintSpan.classList.add("hint-underline");
                    }
                    hintSpan.innerText = String.fromCharCode(hint.character);
                }

                return hintSpan;
            }));
        }

        function applyDrawData(drawElements) {
            clear(context);

            drawElements
                .forEach(drawElement => {
                    const drawData = drawElement.data;
                    if (drawElement.type === "fill") {
                        floodfillUint8ClampedArray(
                            imageData.data,
                            drawData.x, drawData.y,
                            indexToRgbColor(drawData.color),
                            imageData.width, imageData.height);
                    } else if (drawElement.type === "line") {
                        drawLineNoPut(
                            context,
                            imageData,
                            drawData.x, drawData.y,
                            drawData.x2, drawData.y2,
                            indexToRgbColor(drawData.color),
                            drawData.width);
                    } else {
                        console.log("Unknown draw element type: " + drawData.type);
                    }
                });

            context.putImageData(imageData, 0, 0);
        }

        let lastX = 0;
        let lastY = 0;

        let touchID = null;

        function onTouchStart(event) {
            //We only allow a single touch
            if (allowDrawing && touchID == null && localTool !== fillBucket) {
                const touch = event.touches[0];
                touchID = touch.identifier;

                // calculate the offset coordinates based on client touch position and drawing board client origin
                const clientRect = drawingBoard.getBoundingClientRect();
                lastX = (touch.clientX - clientRect.left);
                lastY = (touch.clientY - clientRect.top);
            }
        }

        function onTouchMove(event) {
            // Prevent moving, scrolling or zooming the page
            event.preventDefault();

            if (allowDrawing) {
                for (let i = event.changedTouches.length - 1; i >= 0; i--) {
                    if (event.changedTouches[i].identifier === touchID) {
                        const touch = event.changedTouches[i];

                        // calculate the offset coordinates based on client touch position and drawing board client origin
                        const clientRect = drawingBoard.getBoundingClientRect();
                        const offsetX = (touch.clientX - clientRect.left);
                        const offsetY = (touch.clientY - clientRect.top);

                        // drawing functions must check for context boundaries
                        drawLineAndSendEvent(context, lastX, lastY, offsetX, offsetY);
                        lastX = offsetX;
                        lastY = offsetY;

                        return;
                    }
                }
            }
        }

        function onTouchEnd(event) {
            for (let i = event.changedTouches.length - 1; i >= 0; i--) {
                if (event.changedTouches[i].identifier === touchID) {
                    touchID = null;
                    return;
                }
            }
        }

        drawingBoard.addEventListener('touchend', onTouchEnd);
        drawingBoard.addEventListener('touchcancel', onTouchEnd);
        drawingBoard.addEventListener('touchstart', onTouchStart);
        drawingBoard.addEventListener('touchmove', onTouchMove);

        function onMouseDown(event) {
            if (allowDrawing && event.buttons === 1 && localTool !== fillBucket) {
                const clientRect = drawingBoard.getBoundingClientRect();
                lastX = event.clientX - clientRect.left;
                lastY = event.clientY - clientRect.top;
            }
        }

        function onMouseMove(event) {
            //event.button === 0 could be wrong, as it can also be the uninitialized state.
            //Therefore we use event.buttons, which works differently.
            if (allowDrawing && event.buttons === 1 && localTool !== fillBucket) {
                // calculate the offset coordinates based on client mouse position and drawing board client origin
                const clientRect = drawingBoard.getBoundingClientRect();
                const offsetX = (event.clientX - clientRect.left);
                const offsetY = (event.clientY - clientRect.top);

                // drawing functions must check for context boundaries
                drawLineAndSendEvent(context, lastX, lastY, offsetX, offsetY);
                lastX = offsetX;
                lastY = offsetY;
            }
        }

        function onMouseClick(event) {
            //event.buttons won't work here, since it's always 0. Since we
            //have a click event, we can be sure that we actually had a button
            //clicked and 0 won't be the uninitialized state.
            if (allowDrawing && event.button === 0) {
                if (localTool === fillBucket) {
                    fillAndSendEvent(context, event.offsetX, event.offsetY, localColorIndex);
                } else {
                    drawLineAndSendEvent(context, event.offsetX, event.offsetY, event.offsetX, event.offsetY);
                }
            }
        }

        drawingBoard.addEventListener('mousedown', onMouseDown)
        drawingBoard.addEventListener('mousemove', onMouseMove);
        drawingBoard.addEventListener('mouseleave', onMouseMove);
        drawingBoard.addEventListener('click', onMouseClick);

        function onGlobalMouseMove(event) {
            const clientRect = drawingBoard.getBoundingClientRect();
            lastX = Math.min(clientRect.width - 1, Math.max(0, event.clientX - clientRect.left));
            lastY = Math.min(clientRect.height - 1, Math.max(0, event.clientY - clientRect.top));
        }

        //necessary for mousemove to not use the previous exit coordinates.
        //If this is done via mouseleave and mouseenter of the
        //drawingBoard, the lines will end too early on leave and start
        //too late on exit.
        window.addEventListener('mousemove', onGlobalMouseMove);

        function isAnyDialogVisible() {
            for (let i = 0; i < centerDialogs.children.length; i++) {
                if (centerDialogs.children[i].style.visibility === "visible") {
                    return true;
                }
            }

            return false;
        }

        function onKeyDown(event) {
            //Avoid firing actions if the user is in the chat.
            if (document.activeElement instanceof HTMLInputElement) {
                return;
            }

            //If dialogs are open, it doesn't really make sense to be able to
            //change tools. As this is like being in the pause menu of a game.
            if (isAnyDialogVisible()) {
                return;
            }

            //They key choice was made like this, since it's easy to remember
            //and easy to reach. This is how many MOBAs do it and I personally
            //find it better than having to find specific keys on your
            //keyboard. Especially for people that aren't used to typing
            //without looking at their keyboard, this might help.
            if (event.key === "q") {
                toolButtonPen.click();
                chooseTool(pen);
            } else if (event.key === "w") {
                toolButtonFill.click();
                chooseTool(fillBucket);
            } else if (event.key === "e") {
                toolButtonRubber.click();
                chooseTool(rubber);
            } else if (event.key === "1") {
                sizeButton8.click();
                setLineWidth(8);
            } else if (event.key === "2") {
                sizeButton16.click();
                setLineWidth(16);
            } else if (event.key === "3") {
                sizeButton24.click();
                setLineWidth(24);
            } else if (event.key === "4") {
                sizeButton32.click();
                setLineWidth(32);
            } else if (event.key === 'z' && event.ctrlKey) {
                undoAndSendEvent();
            }
        }

        //Handling events on the canvas directly isn't possible, since the user
        //must've clicked it at least once in order for that to work.
        window.addEventListener("keydown", onKeyDown);

        function debounce(func, timeout) {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => {func.apply(this, args);}, timeout);
            };
        }

        function clear(context) {
            context.fillStyle = "#FFFFFF";
            context.fillRect(0, 0, drawingBoard.width, drawingBoard.height);
            // Refetch, as we don't manually fill here.
            imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
        }

        // Clear initially, as it will be black otherwise.
        clear(context);

        function fillAndSendEvent(context, x, y, colorIndex) {
            const xScaled = convertToServerCoordinate(x);
            const yScaled = convertToServerCoordinate(y);
            const color = indexToRgbColor(colorIndex);
            if (floodfillUint8ClampedArray(imageData.data, xScaled, yScaled, color, imageData.width, imageData.height)) {
                context.putImageData(imageData, 0, 0);
                const fillInstruction = {
                    type: "fill",
                    data: {
                        x: xScaled,
                        y: yScaled,
                        color: colorIndex,
                    },
                };
                socket.send(JSON.stringify(fillInstruction));
            }
        }

        function drawLineAndSendEvent(context, x1, y1, x2, y2) {
            const color = localTool === rubber ? rubberColor : localColor;
            const colorIndex = localTool === rubber ? 0 /* white */ : localColorIndex;

            const x1Scaled = convertToServerCoordinate(x1);
            const y1Scaled = convertToServerCoordinate(y1);
            const x2Scaled = convertToServerCoordinate(x2);
            const y2Scaled = convertToServerCoordinate(y2);
            drawLine(context, imageData, x1Scaled, y1Scaled,
                x2Scaled, y2Scaled, color, localLineWidth);

            const drawInstruction = {
                type: "line",
                data: {
                    x: x1Scaled,
                    y: y1Scaled,
                    x2: x2Scaled,
                    y2: y2Scaled,
                    color: colorIndex,
                    width: localLineWidth,
                }
            };
            socket.send(JSON.stringify(drawInstruction));
        }

    </script>
</body>

</html>
{{end}}
